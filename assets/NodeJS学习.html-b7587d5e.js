import{_ as i,r as a,o as t,c as o,b as e,d as n,e as s,a as r}from"./app-168a97af.js";const c={},p=e("h1",{id:"node",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#node","aria-hidden":"true"},"#"),n(" Node")],-1),d=e("p",null,[e("strong",null,"安装 @types/node 使VScode有node代码的智能提示：npm i -D @types/node")],-1),u=e("h2",{id:"node概述",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#node概述","aria-hidden":"true"},"#"),n(" Node概述")],-1),m={href:"https://nodejs.org/en/",target:"_blank",rel:"noopener noreferrer"},h={href:"http://nodejs.cn/",target:"_blank",rel:"noopener noreferrer"},v=r(`<ul><li>Node是一个js运行环境，基于V8引擎，运行的是高性能V8 JS脚本语言，比浏览器拥有更多的能力</li><li>浏览器中的JS是EcmaScript和Web Api的组合，Web Api提供了BOM、DOM和AJAX来操作浏览器窗口和页面，但能力十分有限，会产生跨域问题和文件读写问题，只能使用浏览器提供的功能做有限的操作</li><li>NodeJS是EcmaScript与Node Api的组合，Node Api几乎提供了所有能做的事，提供了完整的控制计算机的能力，几乎可以通过Node提供的接口，实现对整个操作系统的控制</li><li>单线程、异步、事件驱动</li><li>Node可以开发桌面应用程序，像聊天软件和VScode等，但是目前用Node开发桌面应用程序非常少</li><li>Node最常用于开发服务器应用程序，通常有两个结构 <ul><li>做浏览器与数据库交流的中间服务器应用，常用于微型站点上。Node服务器要完成请求的处理、响应和数据库的交互以及各种业务逻辑</li><li>做浏览器与后端服务器的中间服务器应用，最常见的一种结构，应用在各种规模的站点上。Node服务器不做任何与业务逻辑有关的事情，绝大部分的时候只是简单的转发请求，但可能有时候会有一些额外的功能，比如简单的信息记录(请求日志、用户偏好、广告信息等)、静态资源托管、缓存等</li></ul></li></ul><h2 id="node的全局对象" tabindex="-1"><a class="header-anchor" href="#node的全局对象" aria-hidden="true">#</a> Node的全局对象</h2><p>node内的全局对象是可以直接用的，类似于window</p><ul><li>setTimeout       计时执行，返回结果是一个对象，和window内不同</li><li>setlnterval      每多少时执行，返回结果是一个对象，和window内不同</li><li>setlmmediate     类似于setTimeout0，立即执行，不过与setTimeout0还是有区别的，与node的生命周期有关</li><li>console          控制台</li><li>__dirname        用于获取当前文件夹绝对路径 (并非global属性)</li><li>__filename       用于获取当前文件绝对路径 (并非global属性)</li><li>Buffer           一个类型化数组，继承自UInt8Array，计算机中存储的基本单位是字节，使用和输出时可能需要用十六进制表示，一般不会直接用到，读写文件的时候才会使用</li><li>process <ul><li>cwd()      返回当前nodejs进程的工作目录，绝对路径</li><li>exit()     强制退出当前node进程，可传入退出码，0表示成功退出，默认为0，1表示失败</li><li>argv       String[]，获取命令行所有的参数</li><li>platform   获取当前的操作系统</li><li>kill(pid)  根据进程ID杀死进程</li><li>env        获取环境变量对象</li></ul></li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 获取当前进程的工作目录</span>
<span class="token comment">// console.log(process.cwd());</span>
<span class="token comment">// 获取当前命令中的参数</span>
<span class="token comment">// console.log(process.argv);</span>
<span class="token comment">// 获取操作系统</span>
<span class="token comment">// console.log(process.platform);</span>
<span class="token comment">// 获取全局变量</span>
<span class="token comment">// console.log(p<wbr>rocess.env);</span>

<span class="token comment">// String[]，获取命令行所有的参数</span>
<span class="token comment">// console.log(process.argv);</span>

<span class="token comment">// console.log(global);</span>

<span class="token comment">// 获取当前文件夹绝对路径</span>
<span class="token comment">// console.log(__dirname);</span>
<span class="token comment">// 获取当前文件绝对路径</span>
<span class="token comment">// console.log(__filename);</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="模块的查找" tabindex="-1"><a class="header-anchor" href="#模块的查找" aria-hidden="true">#</a> 模块的查找</h2><ul><li>模块都是根据绝对路径进行直接加载</li><li>相对于当前模块的相对路径./或../会在底层转换为绝对路径进行加载</li><li>相对路径查找顺序： <ul><li>检查是否内置模块，如fs、path等</li><li>检查当前目录中的node_modules</li><li>检查上级目录中的node_modules</li><li>转换为绝对路径</li><li>加载模块</li></ul></li><li>可以不写后缀名，会自动补全，顺序是.js、.json、.node、.mjs</li><li>如果只提供目录不提供文件名，则会自动寻找该目录中的index.js，也可以配置package.json中的main字段(包的默认入口)，导入或执行包时若仅提供目录，则使用main补全入口，默认为index.js</li><li>module对象，记录当前模块信息</li><li>require函数，导出值</li><li>当执行一个模块或使用require时，会将模块放置在一个函数环境中 <ul><li>将path转为绝对路径</li><li>判断该模块是否已有缓存</li><li>读取文件内容</li><li>将文件内容包裹到一个函数中处理 <ul><li>创建module对象</li><li>exports.module = {}</li><li>将数据放入module对象</li></ul></li></ul></li><li>Node中的ES模块化：目前仍然处于试验阶段，Node模块默认是commonJS，ES模块需要将文件后缀名改为.mjs，或最近的package.json中type的值为module，当使用ES模块化运行时，必须添加--experimental-modules标记</li></ul><h2 id="基本内置模块-查文档" tabindex="-1"><a class="header-anchor" href="#基本内置模块-查文档" aria-hidden="true">#</a> 基本内置模块(查文档)</h2><ul><li>os <ul><li>EOL           操作系统特定的行末标志</li><li>arch()        返回为其编译 Node.js 二进制文件的操作系统的 CPU 架构</li><li>cpus()        返回一个对象数组，其中包含有关每个逻辑 CPU 内核的信息</li><li>freemem()     以整数的形式返回空闲的系统内存量（以字节为单位）</li><li>homedir()     返回当前用户的主目录的字符串路径</li><li>hostname()    以字符串的形式返回操作系统的主机名</li><li>tmpdir()      以字符串的形式返回操作系统的默认临时文件目录</li></ul></li><li>path <ul><li>basename      path.basename() 方法会返回 path 的最后一部分，尾部的目录分隔符会被忽略</li><li>sep           提供平台特定的路径片段分隔符，Windows 上是 \\，POSIX 上是 /；在 Windows 上，正斜杠（/）和反斜杠（\\）都被接受为路径片段分隔符。 但是， path 方法只添加反斜杠（\\）</li><li>delimiter     提供平台特定的路径定界符, Windows 是 ; ，POSIX是 :</li><li>dirname       path.dirname() 方法会返回 path 的目录名，类似于 Unix 的 dirname 命令。 尾部的目录分隔符会被忽略</li><li>extname       path.extname() 方法会返回 path 的扩展名，即 path 的最后一部分中从最后一次出现 .（句点）字符直到字符串结束。 如果在 path 的最后一部分中没有 . ，或者如果 path 的基本名称除了第一个字符以外没有 . ，则返回空字符串</li><li>join          path.join() 方法会将所有给定的 path 片段连接到一起（使用平台特定的分隔符作为定界符），然后规范化生成的路径。长度为零的 path 片段会被忽略。 如果连接后的路径字符串为长度为零的字符串，则返回 &#39;.&#39;，表示当前工作目录</li><li>normalize     path.normalize() 方法规范化给定的 path，解析 &#39;..&#39; 和 &#39;.&#39; 片段，当找到多个连续的路径段分隔字符时（例如 POSIX 上的 /、Windows 上的 \\ 或 /），则它们将被替换为单个平台特定的路径段分隔符（POSIX 上的 /、Windows 上的 \\）。 尾部的分隔符会保留。如果 path 是零长度的字符串，则返回 &#39;.&#39;，表示当前工作目录</li><li>relative      path.relative(from, to) 方法根据当前工作目录返回 from 到 to 的<strong>相对路径</strong>。 如果 from 和 to 各自解析到相同的路径（分别调用 path.resolve() 之后），则返回零长度的字符串。如果将零长度的字符串传入 from 或 to，则使用当前工作目录代替该零长度的字符串</li><li>resolve       path.resolve() 方法会将路径或路径片段的序列解析为绝对路径 给定的路径序列会从右到左进行处理，后面的每个 path 会被追加到前面，直到构造出绝对路径。 例如，给定的路径片段序列：/目录1、 /目录2、 目录3，调用 path.resolve(&#39;/目录1&#39;, &#39;/目录2&#39;, &#39;目录3&#39;) 会返回 /目录2/目录3，因为 &#39;目录3&#39; 不是绝对路径，但 &#39;/目录2&#39; + &#39;/&#39; + &#39;目录3&#39; 是。 如果在处理完所有给定的 path 片段之后还未生成绝对路径，则会使用当前工作目录。 生成的路径会被规范化，并且尾部的斜杠会被删除（除非路径被解析为根目录）。 零长度的 path 片段会被忽略。 如果没有传入 path 片段，则 path.resolve() 会返回当前工作目录的绝对路径</li></ul></li><li>url   查文档 <ul><li>据浏览器的约定， URL 对象的所有属性都是在类的原型上实现为getter和setter，而不是作为对象本身的数据属性。因此，与传统的urlObjects不同，在 URL 对象的任何属性(例如 delete myURL.protocol， delete myURL.pathname等)上使用 delete 关键字没有任何效果，但仍返回 true</li></ul></li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> url <span class="token operator">=</span> <span class="token keyword">const</span> url <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URL<span class="token punctuation">.</span>URL</span><span class="token punctuation">(</span>
  <span class="token string">&quot;https://github.com:80/OBKoro1/koro1FileHeader?a=1&amp;b=2#abc&quot;</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// const url = URL.parse(&quot;https://github.com:80/OBKoro1/koro1FileHeader?a=1&amp;b=2#abc&quot;);</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Url {</span>
<span class="token comment">// href: &#39;https://github.com:80/OBKoro1/koro1FileHeader?a=1&amp;b=2#abc&#39;,</span>
<span class="token comment">// origin: &#39;https://github.com:80&#39;,</span>
<span class="token comment">// protocol: &#39;https:&#39;,</span>
<span class="token comment">// username: &#39;&#39;,</span>
<span class="token comment">// password: &#39;&#39;,</span>
<span class="token comment">// host: &#39;github.com:80&#39;,</span>
<span class="token comment">// hostname: &#39;github.com&#39;,</span>
<span class="token comment">// port: &#39;80&#39;,</span>
<span class="token comment">// pathname: &#39;/OBKoro1/koro1FileHeader&#39;,</span>
<span class="token comment">// search: &#39;?a=1&amp;b=2&#39;,</span>
<span class="token comment">// searchParams: URLSearchParams { &#39;a&#39; =&gt; &#39;1&#39;, &#39;b&#39; =&gt; &#39;2&#39; },</span>
<span class="token comment">// hash: &#39;#abc&#39;</span>
<span class="token comment">//   }</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>util <ul><li>callbackify            将 async 异步函数（或者一个返回值为 Promise 的函数）转换成遵循异常优先的回调风格的函数，例如将 (err, value) =&gt; {...} 回调作为最后一个参数。 在回调函数中，第一个参数为拒绝的原因（如果 Promise 解决，则为 null），第二个参数则是解决的值。 回调函数是异步执行的，并且有异常堆栈错误追踪。 如果回调函数抛出一个异常，进程会触发一个 &#39;uncaughtException&#39; 异常，如果没有被捕获，进程将会退出。 null 在回调函数中作为一个参数有其特殊的意义，如果回调函数的首个参数为 Promise 拒绝的原因且带有返回值，且值可以转换成布尔值 false，这个值会被封装在 Error 对象里，可以通过属性 reason 获取。</li><li>inherits               不建议使用 util.inherits()。 请使用 ES6 的 class 和 extends 关键词获得语言层面的继承支持。 这两种方式是语义上不兼容的。 从一个构造函数中继承原型方法到另一个。 constructor 的原型会被设置到一个从 superConstructor 创建的新对象上。 这主要在 Object.setPrototypeOf(constructor.prototype, superConstructor.prototype) 之上添加了一些输入验证。 作为额外的便利，可以通过 constructor.super_属性访问 superConstructor。</li><li>isDeepStrictEqual      util.isDeepStrictEqual(val1, val2), 如果val1和val2之间严格相等，则返回true。否则,返回false。</li><li>promisify              传入一个遵循常见的错误优先的回调风格的函数（即以 (err, value) =&gt; ... 回调作为最后一个参数），并返回一个返回 promise 的版本。</li></ul></li></ul><h2 id="文件的i-o-input-output" tabindex="-1"><a class="header-anchor" href="#文件的i-o-input-output" aria-hidden="true">#</a> 文件的I/O  input output</h2><p>即对外部设备的输入输出，外部设备包含磁盘、网卡、显卡、打印机等设备。IO的速度往往低于内存和CPU的交互速度</p><ul><li>fs模块 (查文档) <ul><li>fs.readFile      异步读取一个文件，回调会传入两个参数 (err, data)，其中 data 是文件的内容。</li></ul></li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>   fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">&#39;文件名&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token keyword">throw</span> err<span class="token punctuation">;</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>fs.writeFile     向文件写入内容</li><li>fs.stat          获取文件或目录信息 <ul><li>size     占用字节</li><li>atime    上次访问时间</li><li>mtime    上次内容被修改时间</li><li>ctime    上次文件状态被修改时间</li><li>birthtime   文件创建时间</li><li>isDirectory()  判断是否是目录</li><li>isFile()       判断是否是文件</li></ul></li><li>fs.readdir       获取目录中的文件和子目录</li><li>fs.mkdir         创建目录</li><li>fs.exists        判断文件或目录是否存在，已经被废弃</li></ul><h2 id="文件流" tabindex="-1"><a class="header-anchor" href="#文件流" aria-hidden="true">#</a> 文件流</h2><ul><li>流是指数据的流动，数据从一个地方缓缓的流动到另一个地方，流是有方向的 <ul><li>可读流：Readable  数据从源头流向内存</li><li>可写流：Writable  数据从内存流向源头</li><li>双工流：Duplex    数据既可从源头流向内存，也可从内存流向源头</li></ul></li><li>其他介质和内存的数据规模和数据处理能力都不一定一致，像磁盘的数据规模比内存大很多，但内存的数据处理速度又比磁盘快得多，所以需要流来做缓冲</li><li>文件流就是内存数据和磁盘文件数据之间的流动</li></ul><h3 id="文件流的创建" tabindex="-1"><a class="header-anchor" href="#文件流的创建" aria-hidden="true">#</a> 文件流的创建</h3><ul><li>fs.createReadStream(path,[options])：创建一个文件可读流，用于读取文件内容 <ul><li>path: 读取的文件路径</li><li>options：可选配置 <ul><li>encoding：编码方式</li><li>start：起始字节</li><li>end：结束字节</li><li>highWaterMark：每次读取数量，如果encoding有值，该数量表示一个字符数，如果encoding为null，该量表示字节数</li></ul></li><li>返回：Readable的子类ReadStream： <ul><li>事件：rs.on(事件名，处理函数) <ul><li>open: 文件打开事件，文件被打开后触发</li><li>error: 发生错误后触发</li><li>close: 文件被关闭后触发，可通过rs.close手动关闭，或文件读取完成后自动关闭，auoClose配置选项，默认为true</li><li>data: 读取到一部分数据后触发，注册data事件后，才会真正开始读取，每次读取highWaterMark指定的读取数量；回调函数中会附带读取到的数据chunk，若指定编码，则读取到的数据会自动按照编码转换为字符串，若没有指定编码，读取到的数据是Buffer</li><li>end: 所有数据读取完毕后触发</li><li>rs.pause(): 暂停读取，会触发pause事件</li><li>rs.resume(): 恢复读取，会触发resume事件</li></ul></li></ul></li></ul></li></ul><h3 id="文件流的写入" tabindex="-1"><a class="header-anchor" href="#文件流的写入" aria-hidden="true">#</a> 文件流的写入</h3><ul><li>fs.createWriteStream(path,[options])：创建一个写入流 <ul><li>path：写入文件的路径</li><li>options：可选配置 <ul><li>flags: 操作文件的方式</li><li>w: 覆盖</li><li>a: 追加</li><li>encoding：编码方式</li><li>start：起始字节</li><li>highWaterMark：每次最多写入的字节数</li></ul></li></ul></li><li>返回：Writable的子类WriteStream <ul><li>ws.on(事件名, 处理函数) <ul><li>open: 文件打开事件，文件被打开后触发</li><li>error: 发生错误后触发close: 文件被关闭后触发</li><li>ws.write(data): 写入一组数据，data可以是字符串或Buffer <ul><li>返回一个boolean值：</li><li>true：写入通道没有被填满，接下来的数据可以直接写入，无须排队</li><li>false：写入通道目前已被填满，接下来的数据将进入写入队列，要特别注意背压问题，因为写入队列是内存中的数据，是有限的</li><li>当写入队列清空时，会触发drain事件</li></ul></li><li>ws.end([data])：结束写入，将自动关闭文件(是否自动关闭取决于autoClose配置，默认为true)，data是可的，表示关闭前最后一次写入</li></ul></li></ul></li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>     rs.pipe(ws): 将可读流连接到可写流，返回参数的值，该方法可解决被压问题
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="net模块" tabindex="-1"><a class="header-anchor" href="#net模块" aria-hidden="true">#</a> net模块</h2><ul><li>http请求有两种模式，一种是普通模式，先经过三次握手，然后客户端发送请求，服务器响应，接着四次挥手断开连接；二是长连接模式，客户端与服务器三次握手后进行持续的请求响应，不断开，一方请求断开的时候再进行四次挥手</li><li>net模块是一个通信模块，它可以实现进程间的通信IPC，网络通信TCP/IP</li><li>创建客户端：net.createConnection(options[, connectListener]) <ul><li>返回socket，socket是一个特殊的文件，在node中表现为一个双工流对象，通过向流写入内容发送数据，通过监听流的内容获取数据</li></ul></li><li>创建服务器：net.createServer() <ul><li>返回server对象： <ul><li>server.listen(port)：监听当前计算机中某个端口</li><li>server.on(&quot;listening&quot;, ()=&gt;{})：开始监听端口后触发的事件</li><li>server.on(&quot;connection&quot;, socket=&gt;{})：当某个连接到来时，触发该事件，事件的监听函数会获得一个socket对象</li></ul></li></ul></li></ul><h2 id="http模块" tabindex="-1"><a class="header-anchor" href="#http模块" aria-hidden="true">#</a> http模块</h2>`,26),k=e("li",null,"http模块建立在net模块之上，无须手动管理socket，无须手动组装消息格式",-1),b={href:"https://nodejs.org/dist/latest-v12.x/docs/api/http.html#http_http_request_url_options_callback",target:"_blank",rel:"noopener noreferrer"},g={href:"https://nodejs.org/dist/latest-v12.x/docs/api/http.html#http_http_createserver_options_requestlistener",target:"_blank",rel:"noopener noreferrer"},_=e("li",null,"总的来说，就是如果是客户端，则请求：ClientRequest对象； 响应：IncomingMessage对象 如果是服务器，则请求：IncomingMessage对象； 响应：ServerResponse对象",-1);function f(x,j){const l=a("ExternalLinkIcon");return t(),o("div",null,[p,d,u,e("p",null,[n("Node官网："),e("a",m,[n("https://nodejs.org/en/"),s(l)]),n(" Node民间中文网："),e("a",h,[n("http://nodejs.cn/"),s(l)])]),v,e("ul",null,[k,e("li",null,[n("http.request(url[, options][, callback]) 请求，查文档："),e("a",b,[n("https://nodejs.org/dist/latest-v12.x/docs/api/http.html#http_http_request_url_options_callback"),s(l)])]),e("li",null,[n("http.createServer([options][, requestListener])  创建服务器，查文档："),e("a",g,[n("https://nodejs.org/dist/latest-v12.x/docs/api/http.html#http_http_createserver_options_requestlistener"),s(l)])]),_])])}const w=i(c,[["render",f],["__file","NodeJS学习.html.vue"]]);export{w as default};
