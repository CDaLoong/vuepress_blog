import{_ as s,r as o,o as d,c as r,b as l,d as n,e as i,a}from"./app-168a97af.js";const t="/vuepress_blog/assets/1-a39009a9.png",c="/vuepress_blog/assets/2-cf0c8394.png",p="/vuepress_blog/assets/3-38b36f5c.png",u="/vuepress_blog/assets/4-458b2710.png",h="/vuepress_blog/assets/5-25c97a06.png",m="/vuepress_blog/assets/6-61a48c76.png",g="/vuepress_blog/assets/7-a1cfbadd.png",b="/vuepress_blog/assets/8-21160396.png",v="/vuepress_blog/assets/9-8f138214.png",k="/vuepress_blog/assets/10-af6f2c83.png",_="/vuepress_blog/assets/11-fa69a322.png",f="/vuepress_blog/assets/12-66d646a8.png",x="/vuepress_blog/assets/13-6bfa33d7.png",y="/vuepress_blog/assets/14-e9eb576d.png",w={},j=a('<h1 id="包管理器" tabindex="-1"><a class="header-anchor" href="#包管理器" aria-hidden="true">#</a> 包管理器</h1><h2 id="包管理工具理解" tabindex="-1"><a class="header-anchor" href="#包管理工具理解" aria-hidden="true">#</a> 包管理工具理解</h2><ul><li><strong>模块（module）</strong><ul><li>通常以单个文件形式存在的功能片段，入口文件通常称之为<strong>入口模块</strong>或<strong>主模块</strong></li></ul></li><li><strong>库（library，简称lib）</strong><ul><li>以一个或多个模块组成的完整功能块，为开发中某一方面的问题提供完整的解决方案</li></ul></li><li><strong>包（package）</strong><ul><li>包含元数据的库，这些元数据包括：名称、描述、git主页、许可证协议、作者、依赖等等</li></ul></li></ul><p><img src="'+t+'" alt="image.png"></p><h3 id="背景" tabindex="-1"><a class="header-anchor" href="#背景" aria-hidden="true">#</a> 背景</h3><ul><li>CommonJS 的出现，使 node 环境下的 JS 代码可以用模块更加细粒度的划分。一个类、一个函数、一个对象、一个配置等等均可以作为模块，这种细粒度的划分，是开发大型应用的基石。</li><li>为了解决在开发过程中遇到的常见问题，比如加密、提供常见的工具方法、模拟数据等等，一时间，在前端社区涌现了大量的第三方库。这些库使用 CommonJS 标准书写而成，非常容易使用。</li><li>然而，在下载使用这些第三方库的时候，遇到难以处理的问题： <ul><li><strong>下载过程繁琐</strong><ul><li>进入官网或 github 主页</li><li>找到并下载相应的版本</li><li>拷贝到工程的目录中</li><li>如果遇到有同名的库，需要更改名称</li></ul></li><li><strong>如果该库需要依赖其他库，还需要按照要求先下载其他库</strong></li><li><strong>开发环境中安装的大量的库如何在生产环境中还原，又如何区分</strong></li><li><strong>更新一个库极度麻烦</strong></li><li><strong>自己开发的库，如何在下一次开发使用</strong></li></ul></li><li><strong>以上问题，就是包管理工具要解决的问题</strong></li></ul><h2 id="前端包管理器" tabindex="-1"><a class="header-anchor" href="#前端包管理器" aria-hidden="true">#</a> 前端包管理器</h2><blockquote><p>npm：重点 yarn：次重点 其他：了解</p></blockquote><ul><li>几乎可以这样认为，前端所有的包管理器都是基于 npm 的，目前，npm 即是一个包管理器，也是其他包管理的基石</li><li>npm 全称为 node package manager，即 node 包管理器，它运行在 node 环境中，让开发者可以用简单的方式完成包的查找、安装、更新、卸载、上传等操作</li></ul><blockquote><p>npm 之所以要运行在 node 环境，而不是浏览器环境，根本原因是因为浏览器环境无法提供下载、删除、读取本地文件的功能。而 node 属于服务器环境，没有浏览器的种种限制，理论上可以完全掌控运行 node 的计算机。</p></blockquote>',10),L=l("li",null,"npm 的出现，弥补了 node 没有包管理器的缺陷，于是很快，node 在安装文件中内置了 npm，当开发者安装好 node 之后，就自动安装了 npm，不仅如此，node 环境还专门为 npm 提供了良好的支持，使用 npm 下载的包更加方便了。",-1),I=l("li",null,[n("registry：入口 "),l("ul",null,[l("li",null,"可以把它想象成一个庞大的数据库"),l("li",null,"第三方库的开发者，将自己的库按照 npm 的规范，打包上传到数据库中"),l("li",null,"使用者通过统一的地址下载第三方包")])],-1),q={href:"https://www.npmjs.com/",target:"_blank",rel:"noopener noreferrer"},C=l("ul",null,[l("li",null,"查询包"),l("li",null,"注册、登录、管理个人信息")],-1),A=l("li",null,[n("CLI：command-line interface 命令行接口 "),l("ul",null,[l("li",null,"安装好 npm 后，通过 CLI 来使用 npm 的各种功能")])],-1),E=a('<blockquote><p>node 和 npm 是互相成就的，node 的出现让 npm 火了，npm 的火爆带动了大量的第三方库的发展，很多优秀的第三方库打包上传到了 npm，这些第三方库又为 node 带来了大量的用户</p></blockquote><h3 id="nrm" tabindex="-1"><a class="header-anchor" href="#nrm" aria-hidden="true">#</a> nrm</h3><p><code>npm install nrm -g</code> 使用 nrm 管理包管理器</p><h3 id="npm" tabindex="-1"><a class="header-anchor" href="#npm" aria-hidden="true">#</a> npm</h3><h4 id="包的安装" tabindex="-1"><a class="header-anchor" href="#包的安装" aria-hidden="true">#</a> 包的安装</h4>',5),T={href:"https://registry.npm.taobao.org",target:"_blank",rel:"noopener noreferrer"},N=l("li",null,[n("设置方式为"),l("code",null,"npm config set registry https://registry.npm.taobao.or")],-1),O=l("li",null,[n("设置好后，通过命令"),l("code",null,"npm config get registry"),n("进行检查")],-1),S=a('<p><img src="'+c+`" alt="image.png"> npm 安装一个包，分为两种安装方式：</p><ol><li>本地安装</li><li>全局安装</li></ol><h5 id="本地安装" tabindex="-1"><a class="header-anchor" href="#本地安装" aria-hidden="true">#</a> 本地安装</h5><ul><li>使用命令<code>npm install 包名</code>或<code>npm i 包名</code>即可完成本地安装</li><li>本地安装的包出现在当前目录下的<code>node_modules</code>目录中 <ul><li>随着开发的进展，<code>node_modules</code>目录会变得异常庞大，目录下的内容不适合直接传输到生产环境，因此通常使用<code>.gitignore</code>文件忽略该目录中的内容</li><li>本地安装适用于绝大部分的包，它会在当前目录及其子目录中发挥作用</li><li>通常在项目的根目录中使用本地安装</li><li>安装一个包的时候，npm 会自动管理依赖，它会下载该包的依赖包到<code>node_modules</code>目录中</li><li>如果本地安装的包带有 CLI，npm 会将它的 CLI 脚本文件放置到<code>node_modules/.bin</code>下，使用命令<code>npx 命令名</code>即可调用</li></ul></li></ul><h5 id="全局安装" tabindex="-1"><a class="header-anchor" href="#全局安装" aria-hidden="true">#</a> 全局安装</h5><ul><li>全局安装的包放置在一个特殊的全局目录，该目录可以通过命令<code>npm config get prefix</code>查看</li><li>使用命令<code>npm install --global 包名</code> 或 <code>npm i -g 包名</code></li><li>重要：<strong>全局安装的包并非所有工程可用，它仅提供全局的 CLI 工具</strong></li><li>大部分情况下，都不需要全局安装包，除非： <ul><li>包的版本非常稳定，很少有大的更新</li><li>提供的 CLI 工具在各个工程中使用的非常频繁</li><li>CLI 工具仅为开发环境提供支持，而非部署环境</li></ul></li></ul><h4 id="包配置" tabindex="-1"><a class="header-anchor" href="#包配置" aria-hidden="true">#</a> 包配置</h4><ul><li>目前遇到的问题： <ul><li>拷贝工程后如何还原？</li><li>如何区分开发依赖和生产依赖？</li><li>如果自身的项目也是一个包，如何描述包的信息</li></ul></li><li>以上这些问题都需要通过包的<strong>配置文件</strong>解决</li></ul><h5 id="配置文件" tabindex="-1"><a class="header-anchor" href="#配置文件" aria-hidden="true">#</a> 配置文件</h5><ul><li>npm 将每个使用 npm 的工程本身都看作是一个包，包的信息需要通过一个名称固定的配置文件来描述</li><li><strong>配置文件的名称固定为：package.json</strong></li><li>可以手动创建该文件，而更多的时候，是通过命令<code>npm init</code>创建的</li><li>配置文件中可以描述大量的信息，包括： <ul><li>name：包的名称，该名称必须是<strong>英文单词字符</strong>，支持连接符</li><li>version：版本 <ul><li>版本规范：主版本号.次版本号.补丁版本号 <ul><li>主版本号：仅当程序发生了重大变化时才会增长，如新增了重要功能、新增了大量的API、技术架构发生了重大变化</li><li>次版本号：仅当程序发生了一些小变化时才会增长，如新增了一些小功能、新增了一些辅助型的API</li><li>补丁版本号：仅当解决了一些 bug 或 进行了一些局部优化时更新，如修复了某个函数的 bug、提升了某个函数的运行效率</li></ul></li></ul></li><li>description：包的描述</li><li>homepage：官网地址</li><li>author：包的作者，必须是有效的 npm 账户名，书写规范是 <code>account &lt;mail&gt;</code><ul><li>例如：<code>zhangsan &lt;zhangsan@gmail.com&gt;</code>，不正确的账号和邮箱可能导致发布包时失败</li></ul></li><li>repository：包的仓储地址，通常指 git 或 svn 的地址，它是一个对象 <ul><li>type：仓储类型，git 或 svn</li><li>url：地址</li></ul></li><li>main：包的入口文件，使用包的人默认从该入口文件导入包的内容</li><li>keywords: 搜索关键字，发布包后，可以通过该数组中的关键字搜索到包</li></ul></li><li>使用<code>npm init --yes</code>或<code>npm init -y</code>可以在生成配置文件时自动填充默认配置</li></ul><h4 id="保存依赖关系" tabindex="-1"><a class="header-anchor" href="#保存依赖关系" aria-hidden="true">#</a> 保存依赖关系</h4><ul><li>大部分时候，我们仅仅是开发项目，并不会把它打包发布出去，尽管如此，我们仍然需要package.json文件</li><li><strong>package.json文件最重要的作用，是记录当前工程的依赖</strong><ul><li>dependencies：生产环境的依赖包</li><li>devDependencies：仅开发环境的依赖包</li></ul></li><li>配置好依赖后，使用下面的命令即可安装依赖</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment">## 本地安装所有依赖 dependencies + devDependencies</span>
<span class="token function">npm</span> <span class="token function">install</span>
<span class="token function">npm</span> i

<span class="token comment">## 仅安装生产环境的依赖 dependencies</span>
<span class="token function">npm</span> <span class="token function">install</span> <span class="token parameter variable">--production</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>这样一来，代码移植就不是问题了，只需要移植源代码和package.json文件，不用移植node_modules目录，然后在移植之后通过命令即可重新恢复安装</li><li>为了更加方便的添加依赖，npm支持在使用install命令时，加入一些额外的参数，用于将安装的依赖包保存到package.json文件中</li><li>涉及的命令如下</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment">## 安装依赖到生产环境</span>
<span class="token function">npm</span> i 包名
<span class="token function">npm</span> i <span class="token parameter variable">--save</span> 包名
<span class="token function">npm</span> i <span class="token parameter variable">-S</span> 包名

<span class="token comment">## 安装依赖到开发环境</span>
<span class="token function">npm</span> i --save-dev 包名
<span class="token function">npm</span> i <span class="token parameter variable">-D</span> 包名
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>自动保存的依赖版本，例如<code>^15.1.3</code>，这种书写方式叫做语义版本号（semver version）</p></blockquote><h4 id="包的使用" tabindex="-1"><a class="header-anchor" href="#包的使用" aria-hidden="true">#</a> 包的使用</h4><ul><li>nodejs 对 npm 支持非常良好</li><li>当使用 nodejs 导入模块时，如果模块路径不是以 ./ 或 ../ 开头，则 node 会认为导入的模块来自于 node_modules 目录，例如：</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> _ <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;lodash&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>它首先会从当前目录的以下位置寻找文件</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>node_modules/lodash.js
node_modules/lodash/入口文件
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>若当前目录没有这样的文件，则会回溯到上级目录按照同样的方式查找</li><li>如果到顶级目录都无法找到文件，则抛出错误</li><li>上面提到的入口文件按照以下规则确定 <ul><li>查看导入包的package.json文件，读取main字段作为入口文件</li><li>若不包含main字段，则使用index.js作为入口文件</li></ul></li></ul><blockquote><p>入口文件的规则同样适用于自己工程中的模块 在 node 中，还可以手动指定路径来导入相应的文件，这种情况比较少见</p></blockquote><h4 id="语义版本" tabindex="-1"><a class="header-anchor" href="#语义版本" aria-hidden="true">#</a> 语义版本</h4><p>思考：如果你编写了一个包A，依赖另外一个包B，你在编写代码时，包B的版本是2.4.1，你是希望使用你包的人一定要安装包B，并且是2.4.1版本，还是希望他可以安装更高的版本，如果你希望它安装更高的版本，高的什么程度呢？</p><ul><li>回顾：版本号规则</li><li>版本规范：主版本号.次版本号.补丁版本号 <ul><li>主版本号：仅当程序发生了重大变化时才会增长，如新增了重要功能、新增了大量的API、技术架构发生了重大变化</li><li>次版本号：仅当程序发生了一些小变化时才会增长，如新增了一些小功能、新增了一些辅助型的API</li><li>补丁版本号：仅当解决了一些 bug 或 进行了一些局部优化时更新，如修复了某个函数的 bug、提升了某个函数的运行效率</li></ul></li><li>有的时候，我们希望：安装我的依赖包的时候，次版本号和补丁版本号是可以有提升的，但是主版本号不能变化</li><li>有的时候，我们又希望：安装我的依赖包的时候，只有补丁版本号可以提升，其他都不能提升</li><li>甚至我们希望依赖包保持固定的版本，尽管这比较少见</li><li>这样一来，就需要在配置文件中描述清楚具体的依赖规则，而不是直接写上版本号那么简单。</li><li>这种规则的描述，即<strong>语义版本</strong></li><li>语义版本的书写规则非常丰富，下面列出了一些常见的书写方式 | 符号 | 描述 | 示例 | 示例描述 | | --- | --- | --- | --- | | &gt; | 大于某个版本 | &gt;1.2.1 | 大于1.2.1版本 | | &gt;= | 大于等于某个版本 | &gt;=1.2.1 | 大于等于1.2.1版本 | | &lt; | 小于某个版本 | &lt;1.2.1 | 小于1.2.1版本 | | &lt;= | 小于等于某个版本 | &lt;=1.2.1 | 小于等于1.2.1版本 | | - | 介于两个版本之间 | 1.2.1 - 1.4.5 | 介于1.2.1和1.4.5之间 | | x | 不固定的版本号 | 1.3.x | 只要保证主版本号是1，次版本号是3即可 | | ~ | 补丁版本号可增 | ~1.3.4 | 保证主版本号是1，次版本号是3，补丁版本号大于等于4 | | ^ | 此版本和补丁版本可增 | ^1.3.4 | 保证主版本号是1，次版本号可以大于等于3，补丁版本号可以大于等于4 | | * | 最新版本 | * | 始终安装最新版本 |</li></ul><h4 id="避免还原的差异" tabindex="-1"><a class="header-anchor" href="#避免还原的差异" aria-hidden="true">#</a> 避免还原的差异</h4><ul><li>版本依赖控制始终是一个两难的问题</li><li>如果允许版本增加，可以让依赖包的bug得以修复（补丁版本号），可以带来一些意外的惊喜（次版本号），但同样可能带来不确定的风险（新的bug）</li><li>如果不允许版本增加，可以获得最好的稳定性，但失去了依赖包自我优化的能力</li><li>而有的时候情况更加复杂，如果依赖包升级后，依赖也发生了变化，会有更多不确定的情况出现</li><li>基于此，npm 在安装包的时候，会自动生成一个 package-lock.json 文件，该文件记录了安装包时的确切依赖关系</li><li>当移植工程时，如果移植了 package-lock.json 文件，恢复安装时，会按照 package-lock.json 文件中的确切依赖进行安装，最大限度的避免了差异</li></ul><h4 id="npm的差异版本处理" tabindex="-1"><a class="header-anchor" href="#npm的差异版本处理" aria-hidden="true">#</a> npm的差异版本处理</h4><p>如果两个包依赖同一个包的不同版本，如下图 <img src="`+p+`" alt="image.png"> 面对这种情况，在 node_modules 目录中，不会使用扁平的目录结构，而会形成嵌套的目录，如下图：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>├── node_modules
│   ├── a 
│   │   ├── node_modules
│   │   │   ├── c
│   │   │   |   |—— c包的文件
│   │   │── a包的文件     
│   ├── b 
│   │   ├── node_modules
│   │   │   ├── c
│   │   │   |   |—— c包的文件
│   │   │── b包的文件
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="npm-脚本-npm-scripts" tabindex="-1"><a class="header-anchor" href="#npm-脚本-npm-scripts" aria-hidden="true">#</a> npm 脚本 （npm scripts）</h4><ul><li>在开发的过程中，我们可能会反复使用很多的 CLI 命令，例如： <ul><li>启动工程命令（node 或 一些第三方包提供的CLI命令）</li><li>部署工程命令（一些第三方包提供的CLI命令）</li><li>测试工程命令（一些第三方包提供的CLI命令）</li></ul></li><li>这些命令纷繁复杂，根据第三方包的不同命令也会不一样，非常难以记忆</li><li>于是，npm 非常贴心的支持了脚本，只需要在 package.json 中配置 scripts 字段，即可配置各种脚本名称</li><li>之后，我们就可以运行简单的指令来完成各种操作了</li><li>运行方式是 <code>npm run 脚本名称</code></li><li>不仅如此，npm 还对某些常用的脚本名称进行了简化，下面的脚本名称是不需要使用run的： <ul><li>start</li><li>stop</li><li>test</li></ul></li></ul><p>一些细节：</p><ul><li>脚本中可以省略npm</li><li>start脚本有默认值：node server.js</li></ul><h4 id="npx" tabindex="-1"><a class="header-anchor" href="#npx" aria-hidden="true">#</a> npx</h4><p>npx是一个工具，npm v5.2.0引入的一条命令（npx），一个npm包执行器，指在提高从npm注册表使用软件包时的体验 ，npm使得它非常容易地安装和管理托管在注册表上的依赖项，npx使得使用CLI工具和其他托管在注册表。 所以现在大部分的开发者都可以直接使用到 npx 的功能。 npx 仍然是一个简单的 cli 工具，来让我们更加方便的执行一些 npm 包，而不用通过 npm 来将包安装到开发者的电脑上面。 主要特点： 1、临时安装可执行依赖包，不用全局安装，不用担心长期的污染。 2、可以执行依赖包中的命令，安装完成自动运行。 3、自动加载node_modules中依赖包，不用指定$PATH。 4、可以指定node版本、命令的版本，解决了不同项目使用不同版本的命令的问题。 npx 为 npm 文件执行功能进行了一些扩展，提供了一种使用 node.js CLI 工具的新方式，这种方式比起以前的执行方式更加灵活，并且对于本地环境变量的污染更小（你可以到自己的 node 安装目录下看一下，有多少个 bin 目录下的软连接在污染你的环境变量）。指定包版本的功能可以让我们更灵活地测试一些新的功能，而不用进行升级和降级，还是能够带来很多方便的。</p><h4 id="运行环境配置" tabindex="-1"><a class="header-anchor" href="#运行环境配置" aria-hidden="true">#</a> 运行环境配置</h4><p>我们书写的代码一般有三种运行环境：</p><ol><li>开发环境</li><li>生产环境</li><li>测试环境</li></ol><ul><li>有的时候，我们可能需要在 node 代码中根据不同的环境做出不同的处理</li><li>如何优雅的让 node 知道处于什么环境，是极其重要的</li><li>通常我们使用如下的处理方式： <ul><li>node中有一个全局变量 global (可以类比浏览器环境的window)，该变量是一个对象，对象中的所有属性均可以直接使用</li><li>global有一个属性是process，该属性是一个对象，包含了当前运行node程序的计算机的很多信息，其中有一个信息是env，是一个对象，包含了计算机中所有的系统变量 <ul><li>通常，我们通过系统变量 NODE_ENV 的值，来判定node程序处于何种环境</li><li>有两种方式设置 NODE_ENV 的值 <ol><li>永久设置</li><li>临时设置</li></ol><ul><li>我们一般使用临时设置</li><li>因此，我们可以配置 scripts 脚本，在设置好了 NODE_ENV 后启动程序</li></ul></li></ul></li></ul></li></ul><blockquote><p>为了避免不同系统的设置方式的差异，可以使用第三方库 cross-env 对环境变量进行设置</p></blockquote><h4 id="在node中读取package-json" tabindex="-1"><a class="header-anchor" href="#在node中读取package-json" aria-hidden="true">#</a> 在node中读取package.json</h4><ul><li>有的时候，我们可能在 package.json 中配置一些自定义的字段，这些字段需要在node中读取</li><li>在node 中，可以直接导入一个json格式的文件，它会自动将其转换为js对象</li></ul><h4 id="其他npm命令" tabindex="-1"><a class="header-anchor" href="#其他npm命令" aria-hidden="true">#</a> 其他npm命令</h4><ul><li>npm install -d 就是 npm install --save-dev 安装到开发环境 例如 gulp ，babel，webpack 一般都是辅助工具</li><li>npm install -s 就是npm install --save 安装到生产环境 如 vue ,react 等</li></ul><h5 id="安装" tabindex="-1"><a class="header-anchor" href="#安装" aria-hidden="true">#</a> 安装</h5><ul><li>精确安装最新版本</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">npm</span> <span class="token function">install</span> --save-exact 包名 
<span class="token function">npm</span> <span class="token function">install</span> <span class="token parameter variable">-E</span> 包名
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>安装指定版本</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">npm</span> <span class="token function">install</span> 包名@版本号
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h5 id="查询" tabindex="-1"><a class="header-anchor" href="#查询" aria-hidden="true">#</a> 查询</h5><ul><li>查询包安装路径</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">npm</span> root <span class="token punctuation">[</span>-g<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>查看包信息</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">npm</span> view 包名 <span class="token punctuation">[</span>子信息<span class="token punctuation">]</span>
<span class="token comment">## view aliases：v info show</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>查询安装包</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">npm</span> list <span class="token punctuation">[</span>-g<span class="token punctuation">]</span> <span class="token punctuation">[</span>--depth<span class="token operator">=</span>依赖深度<span class="token punctuation">]</span>
<span class="token comment">## list aliases: ls  la  ll</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="更新" tabindex="-1"><a class="header-anchor" href="#更新" aria-hidden="true">#</a> 更新</h5><ul><li>检查有哪些包需要更新</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">npm</span> outdated
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>更新包</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">npm</span> update <span class="token punctuation">[</span>-g<span class="token punctuation">]</span> <span class="token punctuation">[</span>包名<span class="token punctuation">]</span>
<span class="token comment">## update 别名（aliases）：up、upgrade</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="卸载包" tabindex="-1"><a class="header-anchor" href="#卸载包" aria-hidden="true">#</a> 卸载包</h5><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">npm</span> uninstall <span class="token punctuation">[</span>-g<span class="token punctuation">]</span> 包名
<span class="token comment">## uninstall aliases: remove, rm, r, un, unlink</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="npm-配置" tabindex="-1"><a class="header-anchor" href="#npm-配置" aria-hidden="true">#</a> npm 配置</h4><ul><li>npm的配置会对其他命令产生或多或少的影响</li><li>安装好npm之后，最终会产生两个配置文件，一个是用户配置，一个是系统配置，当两个文件的配置项有冲突的时候，用户配置会覆盖系统配置</li><li>通常，我们不关心具体的配置文件，而只关心最终生效的配置</li><li>通过下面的命令可以查询目前生效的各种配置</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">npm</span> config <span class="token function">ls</span> <span class="token punctuation">[</span>-l<span class="token punctuation">]</span> <span class="token punctuation">[</span>--json<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>另外，可以通过下面的命令操作配置 <ul><li>获取某个配置项</li></ul></li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">npm</span> config get 配置项
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>设置某个配置项</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">npm</span> config <span class="token builtin class-name">set</span> 配置项<span class="token operator">=</span>值
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>移除某个配置项</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">npm</span> config delete 配置项
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="发布包" tabindex="-1"><a class="header-anchor" href="#发布包" aria-hidden="true">#</a> 发布包</h4><h5 id="准备工作" tabindex="-1"><a class="header-anchor" href="#准备工作" aria-hidden="true">#</a> 准备工作</h5><ul><li>移除淘宝镜像源</li><li>到npm官网注册一个账号，并完成邮箱认证</li><li>本地使用 npm cli 进行登录 <ul><li>使用命令<code>npm login</code>登录</li><li>使用命令<code>npm whoami</code>查看当前登录的账号</li><li>使用命令<code>npm logout</code>注销</li></ul></li><li>创建工程根目录</li><li>使用npm init进行初始化</li></ul><h5 id="发布" tabindex="-1"><a class="header-anchor" href="#发布" aria-hidden="true">#</a> 发布</h5><ul><li>开发</li><li>确定版本</li><li>使用命令<code>npm publish</code>完成发布</li></ul><h3 id="开源协议" tabindex="-1"><a class="header-anchor" href="#开源协议" aria-hidden="true">#</a> 开源协议</h3>`,80),V=l("img",{src:u,alt:"image.png"},null,-1),B={href:"http://choosealicense.online/appendix/",target:"_blank",rel:"noopener noreferrer"},H=l("h2",{id:"yarn",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#yarn","aria-hidden":"true"},"#"),n(" yarn")],-1),D=l("h3",{id:"yarn-简介",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#yarn-简介","aria-hidden":"true"},"#"),n(" yarn 简介")],-1),P={href:"https://www.yarnpkg.com/zh-Hans/",target:"_blank",rel:"noopener noreferrer"},F=a(`<ul><li>yarn 是由Facebook、Google、Exponent 和 Tilde 联合推出了一个新的 JS 包管理工具，<strong>它仍然使用 npm 的registry</strong>，不过提供了全新 CLI 来对包进行管理</li><li>过去，yarn 的出现极大的抢夺了 npm 的市场，甚至有人戏言，npm 只剩下一个 registry 了。</li><li>之所以会出现这种情况，是因为在过去，npm 存在下面的问题： <ul><li>依赖目录嵌套层次深：过去，npm 的依赖是嵌套的，这在 windows 系统上是一个极大的问题，由于众所周知的原因，windows 系统无法支持太深的目录</li><li>下载速度慢 <ul><li>由于嵌套层次的问题，所以npm对包的下载只能是串行的，即前一个包下载完后才会下载下一个包，导致带宽资源没有完全利用</li><li>多个相同版本的包被重复的下载</li></ul></li><li>控制台输出繁杂：过去，npm 安装包的时候，每安装一个依赖，就会输出依赖的详细信息，导致一次安装有大量的信息输出到控制台，遇到错误极难查看</li><li>工程移植问题：由于 npm 的版本依赖可以是模糊的，可能会导致工程移植后，依赖的确切版本不一致</li></ul></li><li>针对上述问题，yarn 从诞生那天就已经解决，它用到了以下的手段： <ul><li>使用扁平的目录结构</li><li>并行下载</li><li>使用本地缓存</li><li>控制台仅输出关键信息</li><li>使用yanr-lock文件记录确切依赖</li></ul></li><li>不仅如此，yarn还优化了以下内容： <ul><li>增加了某些功能强大的命令</li><li>让既有的命令更加语义化</li><li>本地安装的CLI工具可以使用 yarn 直接启动</li><li>将全局安装的目录当作一个普通的工程，生成package.json文件，便于全局安装移植</li></ul></li><li>yarn 的出现给 npm 带来了巨大的压力，很快，npm 学习了 yarn 先进的理念，不断的对自身进行优化，到了目前的npm6版本，几乎完全解决了上面的问题： <ul><li>目录扁平化</li><li>并行下载</li><li>本地缓存</li><li>使用package-lock记录确切依赖</li><li>增加了大量的命令别名</li><li>内置了npx，可以启动本地的CLI工具</li><li>极大的简化了控制台输出</li></ul></li></ul><p><strong>总结</strong></p><ul><li>npm6 之后，可以说npm已经和yarn非常接近，甚至没有差距了。很多新的项目，又重新从yarn转回到npm</li><li>这两个包管理器是目前的主流，都必须要学习</li></ul><h3 id="yarn-的核心命令" tabindex="-1"><a class="header-anchor" href="#yarn-的核心命令" aria-hidden="true">#</a> yarn 的核心命令</h3><ul><li><strong>初始化</strong><ul><li>初始化：<code>yarn init [--yes/-y]</code></li></ul></li><li><strong>安装</strong><ul><li>添加指定包：<code>yarn [global] add package-name [--dev/-D] [--exact/-E]</code>，加global是全局安装</li><li>安装package.json中的所有依赖：<code>yarn install [--production/--prod]</code></li></ul></li><li><strong>脚本和本地CLI</strong><ul><li>运行脚本：<code>yarn run 脚本名</code><ul><li>start、stop、test可以省略run</li></ul></li><li>运行本地安装的CLI：<code>yarn run CLI名</code></li></ul></li><li><strong>查询</strong><ul><li>查看bin目录：<code>yarn [global] bin</code></li><li>查询包信息：<code>yarn info 包名 [子字段]</code></li><li>列举已安装的依赖：<code>yarn [global] list [--depth=依赖深度]</code><ul><li>yarn的list命令和npm的list不同，yarn输出的信息更加丰富，包括顶级目录结构、每个包的依赖版本号</li></ul></li></ul></li><li><strong>更新</strong><ul><li>列举需要更新的包：<code>yarn outdated</code></li><li>更新包：<code>yarn [global] upgrade [包名]</code></li></ul></li><li><strong>卸载</strong><ul><li>卸载包：<code>yarn remove 包名</code></li></ul></li></ul><h3 id="yarn-的特别礼物" tabindex="-1"><a class="header-anchor" href="#yarn-的特别礼物" aria-hidden="true">#</a> yarn 的特别礼物</h3><p>在终端命令上，yarn不仅仅是对npm的命令做了一个改名，还增加了一些原本没有的命令，这些命令在某些时候使用起来非常方便</p><ul><li><strong>yarn check</strong><ul><li>使用<code>yarn check</code>命令，可以验证package.json文件的依赖记录和lock文件是否一致</li><li>这对于防止篡改非常有用</li></ul></li><li><strong>yarn audit</strong><ul><li>使用<code>yarn audit</code>命令，可以检查本地安装的包有哪些已知漏洞，以表格的形式列出，漏洞级别分为以下几种： <ul><li>INFO：信息级别</li><li>LOW: 低级别</li><li>MODERATE：中级别</li><li>HIGH：高级别</li><li>CRITICAL：关键级别</li></ul></li></ul></li><li><strong>yarn why</strong><ul><li>使用<code>yarn why 包名</code>命令，可以在控制台打印出为什么安装了这个包，哪些包会用到它</li></ul></li><li><strong>yarn create</strong><ul><li>非常有趣的命令</li><li>今后，我们会学习一些脚手架，所谓脚手架，就是使用一个命令来搭建一个工程结构</li><li>过去，我们都是使用如下的做法： <ul><li>全局安装脚手架工具</li><li>使用全局命令搭建脚手架</li></ul></li><li>由于大部分脚手架工具都是以<code>create-xxx</code>的方式命名的，比如react的官方脚手架名称为<code>create-react-app</code></li><li>因此，可以使用<code>yarn create</code>命令来一步完成安装和搭建</li></ul></li></ul><p>例如：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">yarn</span> create react-app my-app
<span class="token comment"># 等同于下面的两条命令</span>
<span class="token function">yarn</span> global <span class="token function">add</span> create-react-app
create-react-app my-app
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="cnpm" tabindex="-1"><a class="header-anchor" href="#cnpm" aria-hidden="true">#</a> cnpm</h2>`,11),G={href:"https://npm.taobao.org/",target:"_blank",rel:"noopener noreferrer"},M=a('<ul><li>为解决国内用户连接npm registry缓慢的问题，淘宝搭建了自己的registry，即淘宝npm镜像源</li><li>过去，npm没有提供修改registry的功能，因此，淘宝提供了一个CLI工具即cnpm，它支持除了<code>npm publish</code>以外的所有命令，只不过连接的是淘宝镜像源</li><li>如今，npm已经支持修改registry了，可能cnpm唯一的作用就是和npm共存，即如果要使用官方源，则使用npm，如果使用淘宝源，则使用cnpm</li></ul><h2 id="nvm" tabindex="-1"><a class="header-anchor" href="#nvm" aria-hidden="true">#</a> nvm</h2><ul><li>nvm并非包管理器，它是用于管理多个node版本的工具</li><li>在实际的开发中，可能会出现多个项目分别使用的是不同的node版本，在这种场景下，管理不同的node版本就显得尤为重要</li><li>nvm就是用于切换版本的一个工具</li></ul><h3 id="下载和安装" tabindex="-1"><a class="header-anchor" href="#下载和安装" aria-hidden="true">#</a> 下载和安装</h3>',4),z={href:"https://github.com/coreybutler/nvm-windows/releases",target:"_blank",rel:"noopener noreferrer"},J=a('<h3 id="使用nvm" tabindex="-1"><a class="header-anchor" href="#使用nvm" aria-hidden="true">#</a> 使用nvm</h3><ul><li>nvm提供了CLI工具，用于管理node版本</li><li>在终端中输入nvm，以查看各种可用命令</li><li>M1 安装 node 低版本时，先执行 <code>arch -x86_64 zsh</code>，再进行 <code>nvm install</code></li><li>查看 node 所有版本 <code>nvm ls-remote</code></li><li>nvm 修改默认版本 <code>nvm alias default 16.13.1</code></li></ul>',2),$={href:"https://npm.taobao.org/mirrors/node/",target:"_blank",rel:"noopener noreferrer"},U={href:"https://npm.taobao.org/mirrors/npm/",target:"_blank",rel:"noopener noreferrer"},R=a('<h2 id="volta" tabindex="-1"><a class="header-anchor" href="#volta" aria-hidden="true">#</a> volta</h2><ul><li>volta 是新一代的node版本管理工具，</li><li>它具有以下特点： <ul><li>rust编译，更安全且加载运行速度更快</li><li>多个项目无缝切换node版本或包管理器</li><li>跨平台，包括Windows和所有Unix shell(Linux\\macOS)</li><li>支持node、npm、yarn、pnpm等多个包管理器</li><li>拥有可扩展性钩子，可以定制化</li></ul></li></ul><h3 id="下载和安装-1" tabindex="-1"><a class="header-anchor" href="#下载和安装-1" aria-hidden="true">#</a> 下载和安装</h3>',3),W={href:"https://volta.sh/",target:"_blank",rel:"noopener noreferrer"},K=a('<ul><li>curl https://get.volta.sh | bash</li><li>Mac M1 安装完成后需要手动配置 shell 和 path，否则使用 volta 下载 node 的时候会报错 <ul><li><code>export VOLTA_HOME=&quot;$HOME/.volta&quot;</code></li><li><code>export PATH=&quot;$VOLTA_HOME/bin:$PATH&quot;</code></li></ul></li></ul><h3 id="使用volta" tabindex="-1"><a class="header-anchor" href="#使用volta" aria-hidden="true">#</a> 使用volta</h3><ul><li>volta fetch [FLAGS] &lt;tool[@version]&gt; 将工具下载到本地缓存中，而无需将其设置为默认值或使其可用，以供将来离线使用 <ul><li>Tools to fetch, like <code>node</code>, <code>yarn@latest</code> or <code>your-package@^14.4.3</code></li></ul></li><li>volta install [FLAGS] &lt;tool[@version]&gt; 设置工具的默认版本，如果该工具尚未在本地缓存，它也会获取该工具 <ul><li>Tools to install, like <code>node</code>, <code>yarn@latest</code> or <code>your-package@^14.4.3</code></li></ul></li><li>volta uninstall [FLAGS] &lt;tool[@version]&gt; 删除已使用 volta install 安装的任何全局软件包 <ul><li>The tool to uninstall, e.g. <code>node</code>, <code>npm</code>, <code>yarn</code>, or <code>&lt;package&gt;</code></li></ul></li><li>volta pin [FLAGS] &lt;tool[@version]&gt; 更新项目的 package.json 文件以使用选定版本的工具 <ul><li>Tools to pin, like <code>node@lts</code> or <code>yarn@^1.14</code></li><li>会将版本信息记录在 package.json 的 <code>&quot;volta&quot;: {}</code> 里，再次打开控制台将读取此信息使用记录的版本，不同项目无缝丝滑切换</li></ul></li><li>volta list [FLAGS] [OPTIONS] [tool] 检查已安装的 Node 版本、包管理器和带有二进制文件的包 <ul><li>The tool to lookup: <code>all</code>, <code>node</code>, <code>yarn</code>, or the name of a package or binary</li><li>volta list all 查看所有已安装的工具</li><li>volta list node 查看所有已安装的 Node 版本</li></ul></li></ul>',3),Q={href:"https://docs.volta.sh/reference/",target:"_blank",rel:"noopener noreferrer"},X=a(`<h2 id="pnpm" tabindex="-1"><a class="header-anchor" href="#pnpm" aria-hidden="true">#</a> pnpm</h2><ul><li>pnpm是一种新起的包管理器，从npm的下载量看，目前还没有超过yarn，但它的实现方式值得主流包管理器学习，某些开发者极力推荐使用pnpm</li><li>从结果上来看，它具有以下优势： <ul><li>目前，安装效率高于npm和yarn的最新版</li><li>极其简洁的node_modules目录</li><li>避免了开发时使用间接依赖的问题</li><li>能极大的降低磁盘空间的占用</li></ul></li></ul><h3 id="安装和使用" tabindex="-1"><a class="header-anchor" href="#安装和使用" aria-hidden="true">#</a> 安装和使用</h3><ul><li>全局安装pnpm</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">npm</span> <span class="token function">install</span> <span class="token parameter variable">-g</span> <span class="token function">pnpm</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>之后在使用时，只需要把npm替换为pnpm即可</li><li>如果要执行安装在本地的CLI，可以使用pnpx，它和 npx 的功能完全一样，唯一不同的是，在使用pnpx执行一个需要安装的命令时，会使用pnpm进行安装</li></ul><blockquote><p>比如<code>npx mocha</code>执行本地的<code>mocha</code>命令时，如果<code>mocha</code>没有安装，则npx会自动的、临时的安装mocha，安装好后，自动运行mocha命令</p></blockquote><h3 id="pnpm原理" tabindex="-1"><a class="header-anchor" href="#pnpm原理" aria-hidden="true">#</a> pnpm原理</h3><ul><li>同 yarn 和 npm 一样，pnpm 仍然使用缓存来保存已经安装过的包，以及使用 pnpm-lock.yaml 来记录详细的依赖版本</li><li>不同于 yarn 和 npm， pnpm 使用<strong>符号链接和硬链接</strong>（可将它们想象成快捷方式）的做法来放置依赖，从而规避了从缓存中拷贝文件的时间，使得安装和卸载的速度更快</li><li>由于使用了<strong>符号链接和硬链接</strong>，pnpm可以规避windows操作系统路径过长的问题，因此，它选择使用树形的依赖结果，有着几乎完美的依赖管理。也因为如此，项目中只能使用直接依赖，而不能使用间接依赖</li></ul><h3 id="注意事项" tabindex="-1"><a class="header-anchor" href="#注意事项" aria-hidden="true">#</a> 注意事项</h3><ul><li>由于 pnpm 会改动 node_modules 目录结构，使得每个包只能使用直接依赖，而不能使用间接依赖，因此，如果使用 pnpm 安装的包中包含间接依赖，则会出现问题(<strong>现在不会了，除非使用了绝对路径</strong>)</li><li>由于 pnpm 超高的安装卸载效率，越来越多的包开始修正之前的间接依赖代码</li></ul><h3 id="概念" tabindex="-1"><a class="header-anchor" href="#概念" aria-hidden="true">#</a> 概念</h3><blockquote><p>要彻底理解pnpm是怎么做的，需要有一些操作系统知识</p></blockquote><ul><li><strong>文件的本质</strong><ul><li>在操作系统中，文件实际上是一个指针，只不过它指向的不是内存地址，而是一个外部存储地址（这里的外部存储可以是硬盘、U盘、甚至是网络）<img src="`+h+'" alt="image.png"></li><li>当我们删除文件时，删除的实际上是指针，因此，无论删除多么大的文件，速度都非常快。<img src="'+m+'" alt="image.png"></li></ul></li><li><strong>文件的拷贝</strong><ul><li>如果你复制一个文件，是将该文件指针指向的内容进行复制，然后产生一个新文件指向新的内容</li></ul></li></ul><p><img src="'+g+'" alt="image.png"></p><ul><li><strong>硬链接 hard link</strong><ul><li>硬链接的概念来自于 Unix 操作系统，它是指将一个文件A指针复制到另一个文件B指针中，文件B就是文件A的硬链接</li></ul></li></ul><p><img src="'+b+`" alt="image.png"></p><ul><li>通过硬链接，不会产生额外的磁盘占用，并且，两个文件都能找到相同的磁盘内容</li><li>硬链接的数量没有限制，可以为同一个文件产生多个硬链接</li><li>windows Vista操作系统开始，支持了创建硬链接的操作，在cmd中使用下面的命令可以创建硬链接</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>mklink /h 链接名称 目标文件
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>由于文件夹（目录）不存在文件内容，所以文件夹（目录）不能创建硬链接</li></ul><blockquote><p>由于种种原因，在windows操作系统中，通常不要跨越盘符创建硬链接</p></blockquote><ul><li><strong>符号链接 symbol link</strong><ul><li>符号链接又称为软连接，如果为某个文件或文件夹A创建符号连接B，则B指向A。</li></ul></li></ul><p><img src="`+v+`" alt="image.png"></p><ul><li>windows Vista操作系统开始，支持了创建符号链接的操作，在cmd中使用下面的命令可以创建符号链接：</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>mklink /d 链接名称 目标文件
<span class="token comment"># /d表示创建的是目录的符号链接，不写则是文件的符号链接</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>早期的windows系统不支持符号链接，但它提供了一个工具junction来达到类似的功能</p></blockquote><ul><li><strong>符号链接和硬链接的区别</strong><ul><li>硬链接仅能链接文件，而符号链接可以链接目录</li><li>硬链接在链接完成后仅和文件内容关联，和之前链接的文件没有任何关系。而符号链接始终和之前链接的文件关联，和文件内容不直接相关</li></ul></li><li><strong>快捷方式</strong><ul><li>快捷方式类似于符号链接，是windows系统早期就支持的链接方式</li><li>它不仅仅是一个指向其他文件或目录的指针，其中还包含了各种信息：如权限、兼容性启动方式等其他各种属性</li><li>由于快捷方式是windows系统独有的，在跨平台的应用中一般不会使用</li></ul></li><li><strong>node环境对硬链接和符号链接的处理</strong><ul><li><strong>硬链接</strong>：硬链接是一个实实在在的文件，node不对其做任何特殊处理，也无法区别对待，实际上，node根本无从知晓该文件是不是一个硬链接</li><li><strong>符号链接</strong>：由于符号链接指向的是另一个文件或目录，当node执行符号链接下的JS文件时，会使用原始路径</li></ul></li></ul><h3 id="pnpm原理-1" tabindex="-1"><a class="header-anchor" href="#pnpm原理-1" aria-hidden="true">#</a> pnpm原理</h3><ul><li>pnpm使用符号链接和硬链接来构建node_modules目录</li><li>下面用一个例子来说明它的构建方式 <ul><li>假设两个包a和b，a依赖b：</li></ul></li></ul><p><img src="`+k+'" alt="image.png"></p><ul><li>假设我们的工程为proj，直接依赖a，则安装时，pnpm会做下面的处理 <ul><li>查询依赖关系，得到最终要安装的包：a和b</li><li>查看a和b是否已经有缓存，如果没有，下载到缓存中，如果有，则进入下一步</li><li>创建 node_modules 目录，并对目录进行结构初始化</li></ul></li></ul><p><img src="'+_+'" alt="image.png"></p><ul><li>从缓存的对应包中使用硬链接放置文件到相应包代码目录中</li></ul><p><img src="'+f+'" alt="image.png"></p><ul><li>使用符号链接，将每个包的<strong>直接依赖</strong>放置到自己的目录中</li></ul><p><img src="'+x+`" alt="image.png"></p><pre><code>  - 这样做的目的，是为了保证a的代码在执行过程中，可以读取到它们的直接依赖
</code></pre><ul><li>新版本的pnpm为了解决一些书写不规范的包（读取间接依赖）的问题，又将所有的工程非直接依赖，使用符号链接加入到了 .pnpm/node_modules 中</li><li>在本例中好像没有必要，但是如果b依赖c，a又要直接用c，这种不规范的用法现在pnpm通过这种方式支持了。 <ul><li>但对于那些使用绝对路径的奇葩写法，可能永远也无法支持</li></ul></li><li>在工程的node_modules目录中使用符号链接，放置直接依赖</li></ul><p><img src="`+y+'" alt="image.png"></p>',39);function Y(Z,ll){const e=o("ExternalLinkIcon");return d(),r("div",null,[j,l("ul",null,[L,l("li",null,[n("npm 由三部分组成： "),l("ul",null,[I,l("li",null,[n("官网："),l("a",q,[n("https://www.npmjs.com/"),i(e)]),C]),A])])]),E,l("ul",null,[l("li",null,[n("安装（install），即下载包 由于 npm 的官方 registry 服务器位于国外，可能受网速影响导致下载缓慢或失败。因此，安装好 npm 之后，需要重新设置 registry 的地址为国内地址 "),l("ul",null,[l("li",null,[n("目前，淘宝 "),l("a",T,[n("https://registry.npm.taobao.org"),i(e)]),n(" 提供了国内的 registry 地址，先设置到该地址")]),N,O])])]),S,l("p",null,[V,n(" 可以通过网站 "),l("a",B,[n("http://choosealicense.online/appendix/"),i(e)]),n(" 选择协议，并复制协议内容")]),H,D,l("blockquote",null,[l("p",null,[n("yarn 官网："),l("a",P,[n("https://www.yarnpkg.com/zh-Hans/"),i(e)])])]),F,l("blockquote",null,[l("p",null,[n("官网地址："),l("a",G,[n("https://npm.taobao.org/"),i(e)])])]),M,l("p",null,[n("最新版下载地址："),l("a",z,[n("https://github.com/coreybutler/nvm-windows/releases"),i(e)]),n(" 下载nvm-setup.zip后，直接安装")]),J,l("blockquote",null,[l("p",null,[n("为了加快下载速度，建议设置淘宝镜像 node淘宝镜像："),l("a",$,[n("https://npm.taobao.org/mirrors/node/"),i(e)]),n(" npm淘宝镜像："),l("a",U,[n("https://npm.taobao.org/mirrors/npm/"),i(e)])])]),R,l("p",null,[n("官网："),l("a",W,[n("https://volta.sh/"),i(e)])]),K,l("p",null,[n("其他的用法参考官网，很详细："),l("a",Q,[n("https://docs.volta.sh/reference/"),i(e)])]),X])}const el=s(w,[["render",Y],["__file","包管理器学习.html.vue"]]);export{el as default};
