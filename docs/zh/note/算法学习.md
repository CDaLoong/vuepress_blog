[toc]

# 算法要素(写在最上边)

 1. 严谨性判断，不允许任何报错
 2. 任何递归程序，先写出口
 3. 任何一种算法，都没有优劣之分，只有是否适合的场景


# 数据结构

    可以容纳数据的结构被称为数据结构，算法是用来对数据结构进行处理的方法

    数据结构是静态的，算法是动态的


# 一位数据结构(线性数据结构)

    1. 线性数据结构强调存储与顺序

## 线性数据结构的遍历

   将一个集合中的每一个元素进行获取并查看

## 数组(内置)

 - 例：数组 a = [1,2,3,4,5,6,7,8,9]; 
    - a[1], 方括号表示存储地址的偏移。  操作系统知识：通过偏移查询数据性能最好。

    - 数组增加数据时如果长度不够，则会在底层新创建一个长度更长的数组，把原来数组的数组复制过来，再在最后添加一个数据，所以是耗性能的

 1. 数组特性: 
    1. 存储在物理空间上是连续的；
    2. 底层的数组长度是不可变的；
    3. 数组的变量，指向数组第一个元素的位置。

 2. 数组的优点(只有一个)：查询性能好，指定查询某个位置。

 3. 数组的缺点：
    1. 因为空间必须得是连续的，所以如果数组比较大，当系统的空间碎片较多的时候，容易存不下；
    2. 因为数组的长度是固定的，所以数组的内容难以被添加和删除。
    

 - 内容固定时var a = [1,2,3,4,5,6,7,8,9]; 性能是可以的，很高

 - 内容不固定时，先声明数组长度性能是最高的，var arr = new Array(10);


## 链表

 - 如果要传递一个链表，必须传递链表的根节点

 - 每一个节点，都认为自己是根节点，因为只有下一个引用，而找不到上一个引用

 1. 链表的特点：
    1. 空间上是不连续的；
    2. 每存放一个值，都要多开销一个引用空间。


 2. 链表的优点：
    1. 只要内存足够大，就能存的下，不用担心空间碎片问题(在连续排列的数据中，每删除一个数据就会留下一个坑位，当数据特别多，删除的数据留下的坑位就被成为空间碎片)；
    2. 链表的添加和删除非常容易，只需改变引用即可。
   
 3. 链表的缺点
    1. 查询速度慢(指查询某个位置)；
    2. 链表每一个节点都需要创建一个指向next的引用，浪费一些空间，当节点内数据越多的时候，这部分开销的内存影响越小。

 4. 链表的遍历
    1. 循环遍历，for循环，while循环，性能更好，但是常用于遍历数组；
    2. 递归遍历，内部调用自身，记得留出口，经常使用，往往能大量节省开发时间和开发效率，任何递归程序先写出口。

 5. 链表的逆序
    1. 让最后一个节点指向倒数第二个节点，让倒数第二个节点指向null，然后进行递归逆序。

 6. 双向链表
   双指向的链表，即包含下一个引用，也包含上一个引用，但是双向链表所有能实现的功能单向链表都能实现
   优点：无论给出哪个节点，都可以对整个链表进行遍历
   缺点：多耗费一个引用的空间，而且构建双向链表比较复杂，所以很少使用双向链表


## 冒泡排序
 
 最慢的排序算法之一，但是是最容易实现的排序算法

 1. 排序的本质是比较和交换，先比较看是否需要交换，先把数值的最大值或最小值放在一端，数据值就像气泡一样从数组的一端漂浮到另一端；
 2. for循环内嵌套for循环，外循环遍历数组每一项，内循环比较元素，如需交换调用函数即可。

## 选择排序
 
 1. 内层循环，每一圈选出一个最大或最小值，放在最后面;
 2. 选择排序从数组的开头开始，将第一个元素和其他元素进行比较。检查完所有元素后，最小的元素会被放在第一或者最后一个位置，然后算法会从第二个或者倒数第二个位置继续。这个过程一直进行，进行到倒数第二个位置时，完成排序。

## 快速排序

 1. 处理大数据集最快的算法之一，分而治之，通过递归的方法将数据依次分解为包含较小元素和较大元素的不同子序列，不断重复这个步骤直到所有数据都是有序的。
 2. 首先要在列表中选择一个基准值，数据排序围绕基准值进行，列表中小于基准值的元素移到数组底部，大于基准值的元素移到数组顶部。
 3. 快速排序算法：
    1. 选择一个基准元素，将列表分隔成两个子序列；
    2. 对列表重新排序，将所有小于基准值的元素放在基准值的前面，所有大于基准值的元素放在基准值的后面；
    3. 分别对较小元素的子序列和较大元素的子序列重复步骤1和2。

 4. 标准快速排序算法：
    1. 传入一个数组，一个初始比对元素索引，一个最后一个元素索引；
    2. 在函数中将初始元素索引赋值给left，将最后一个元索引赋值给right；
    3. 当left小于right时，如果数组left值小于初始元素索引的值，并且left < right时，让left++，如果数组right的值大于初始比对元素索引的值，并且left > right时，让right--；
    4. 当遇见left对应的值大于初始元素索引的值，right的值小于初始元素索引的值，让left和right对应的值交换位置；
    5. 当left = right时，让初始比对值和right - 1的值进行交换，当left != right时，让初始比对值和right的值进行交换；
    6. 递归传入数组，初始比对元素索引，left；
    7. 递归传入数组，交换后的初始比对值，最后一元素索引
   
 5. 标准快速排序就是先选择一个基准值，在挨个与基准值比较，找到比基准值小的和比基准值大的交换位置，让比基准值小的放一边，比基准值大的放另一边，然后把基准值放在中间，再对两边进行递归比较

## 栈和队列

 1. 栈，先入后出，后入先出，比如摞盘子，只能通过栈顶访问；
 2. 队列，先入先出，像个管道，一头进一头出；
 3. 可以使用数组的push、pop和shift方法模拟栈和队列。


## 二维数据结构

### 二维数组结构

 1. 数组里的每一项也都是数组，由行和列构成的数据表格，可以按行或者按列访问

### 二维拓补结构(图，散列数学)

   只关注关系，是否有联系，不关注位置和距离，一个顶点既可以有一条边，也可以有多条边与它相连，通常将图的边称为邻接表或者邻接表数组，以此顶点为索引，可以高效访问与这个顶点相连的所有顶点的列表

 1. 图是边和顶点的集合
 2. 类似于村庄之间相连的道路，每两个村庄之间都由某条道路相连，每个村庄都可以看做一个顶点，它们之间是有关系的，也就是成为一种数据结构
 3. 但是图也分为有序图和无序图(无向图)，有序图是单向的路径，能去不能回，也就是存有单向的引用，无序图是双向的路径，能来能回，互相存有对方的引用
 4. 顶点内存有的引用放在数组里，可以称为连通的邻居

## 树形结构

   计算机的树，都是倒着长的，根节点，子节点，叶子结点，树的度，树的深度
   非线性数据结构，以分层的方式存储数据，用来存储有层级关系的数据，如文件系统中的文件，还被用来存储有序列表

 1. 有向无环图，是图的一种
 2. 树形结构只有一个根节点，并且没有回路，单向引用
 3. 根节点是树的根，只有一个
 4. 子节点是某个节点下面的节点，类似于树枝
 5. 叶子节点是下边没有其他节点了，就是树叶
 6. 一棵树有最多叉的节点有多少个叉就代表这棵树的度为多少
 7. 一棵树有几层，也就是从根节点到最下边的叶子节点有几层，就代表树的深度为几

### 二叉树
 
   树的度最多为2的树形结构，一般父节点的两个子节点分别称为左节点和右节点
   在二叉树中，每个节点都认为自己是根节点
   子树：二叉树中，每一个节点或叶子节点，都是一颗子树的根节点，两个节点也被称为左子树和右子树


#### 满二叉树

   1. 所有的叶子节点都在最底层
   2. 每个非叶子节点都有两个子节点

#### 完全二叉树

 1. 国内定义：
    1. 叶子节点都在最后一层或倒数第二层
    2. 叶子节点都向左聚拢，最后一层的叶子节点均需在最左边

 2. 国际定义：
    1. 叶子节点都在最后一层或倒数第二层
    2. 如果有叶子节点，就必然有两个叶子节点(两个子节点一个有两个叶子节点一个没有叶子节点也符合，但如果另一个子节点有且只有一个叶子节点，则不符合)

#### 二叉树的遍历
 
 ```mermaid
 graph TD;
 A-->C;
 A-->B;
 C-->F;
 C-->G;
 B-->D;
 B-->E;
 ```

 1. 前序遍历(先根次序遍历)：ACFGBDE
      先打印当前的，再打印左边的，再打印右边的;
      ```js
      let traversal = (node) => {
      if(node === null) { return }
      console.log(node.value);
      traversal(node.left);
      traversal(node.right);
      }
      ```

 2. 中序遍历(中根次序遍历)：FCGADBE
      先打印左边的，再打印当前的，再打印右边的，类似将所有节点从左往右依次投影到一条线上
      ```js
      let traversal = (node) => {
      if(node === null) { return }
      traversal(node.left);
      console.log(node.value);
      traversal(node.right);
      }
      ```

 3. 后序遍历: FGCDEBA
      先打印左边的，再打印右边的，再打印当前的
      ```js
      let traversal = (node) => {
      if(node === null) { return }
      traversal(node.left);
      traversal(node.right);
      console.log(node.value);
      }
      ```

 4. 从哪个顺序打印就看什么时候打印自身,有中序结果和前序或后序结果的其中一个就可以进行反推二叉树

 5. 根据已知前序中序还原二叉树：
      先去看算法要素，然后根据前序第一个确定根节点，然后找到中序中的根节点确定左子树的所有节点和右子树的所有节点，再在前序里找到所有左子树和右子树的节点，然后递归查找
      ```js
         let f1 = (qian, zhong) => {
         if(qian === null || zhong === null || qian.length === 0 || zhong.length    === 0 || qian.length !== zhong.length) { return null };
         let root = new node(qian[0]);
         let index = zhong.indexOf(root.value);
         let qianLift = qian.slice(1, 1 + index);
         let qianRight = qian.slice(1 + index, qian.length);
         let zhongLeft = zhong.slice(0, index);
         let zhongRight = zhong.slice(index + 1, zhong.length);
         root.left = f1(qianLift, zhongLeft);
         root.right = f1(qianRight, zhongRight);
         return root;
         }
      ```
      
 6. 根据已知中序后序还原二叉树：
      先去看算法要素，然后根据后序最后一个确定根节点，然后找到中序中的根节点确定左子树的所有节点和右子树的所有节点，再在后序里找到所有左子树和右子树的节点，然后递归查找
      ```js
         let f2 = (zhong, hou) => {
         if(hou === null || zhong === null || hou.length === 0 || zhong.length   === 0 || hou.length !== zhong.length) { return null };
         let root = new node(hou[hou.length - 1]);
         let index = zhong.indexOf(root.value);
         let houLift = hou.slice(0, index);
         let houRight = hou.slice(index, hou.length - 1);
         let zhongLeft = zhong.slice(0, index);
         let zhongRight = zhong.slice(index + 1, zhong.length);
         root.left = f2(zhongLeft, houLift);
         root.right = f2(zhongRight, houRight);
         return root;
         }
      ```

#### 二叉树的搜索

 1. 深度优先搜索：更适合探索未知，能查多少查多少
   先比对根节点，根节点不是开始查左子树，从左往有把左子树查完再查根节点下的右子树(从左往右)
   对于二叉树来说，深度优先搜索和前序遍历的顺序是一样的
   ```js
      let deepSearch = (root, target) => {
         if(root === null) { return false };
         if(root.value === target) { return true };
         let left = deepSearch(root.left, target);
         let right = deepSearch(root.right, target);
         return left || right;
      }
   ```
 
 2. 广度优先搜索：更适合探索局域，知道大概在某一块
   一层一层的搜索，比对完根节点开始比对左子树和右子树，然后再比对左子树右子树下边的左子树右子树
   ```js
      let scopeSearch = (rootList, target) => {
         if(rootList === null || rootList.length === 0) { return false };
         let childList = [];
         for(let i = 0; i < rootList.length; i ++) {
             if(rootList[i] !== null && rootList[i].value === target) { 
                 return true 
             } else{
                 if(rootList[i].left !== null) {
                     childList.push(rootList[i].left);
                 }
                 if(rootList[i].right !== null) {
                     childList.push(rootList[i].right);
                 }
             };
         }
         return scopeSearch(childList, target);
      }
   ```

#### 二叉树的比较

 1. 遇到二叉树的比较问题时，先必须要确定左右两棵子树交换位置，即左右互换算不算同一颗二叉树。如果是笔试的话，默认互换后不是同一棵树，如果有特殊说明左右互换还是同一棵树，就按说明处理。面试的时候最好问一下面试官

 2. 左右互换不是同一颗二叉树：先看看二叉树是不是同一棵，再进行严谨性判断，然后比较数值，接着递归比较
    ```js
      let compareTree = (root1, root2) => {
         if(root1 === root2) { return true };
         if(root1 === null && root2 !== null || root1 !== null && root2 === null) { return false };
         if(root1.value !== root2.value) { return false };
         let leftBool = compareTree(root1.left, root2.left);
         let rightBool = compareTree(root1.right, root2.right);
         return leftBool && rightBool;
      }
    ```

 3. 左右互换是同一棵二叉树：判断两棵子树是否相等
    ```js
      let compareTree = (root1, root2) => {
         if(root1 === root2) { return true };
         if(root1 === null && root2 !== null || root1 !== null && root2 === null) { return false };
         if(root1.value !== root2.value) { return false };
         let leftBool = compareTree(root1.left, root2.left);
         let leriBool = compareTree(root1.left, root2.right);
         let rightBool = compareTree(root1.right, root2.right);
         let rileBool = compareTree(root1.right, root2.left);
         return leftBool && rightBool || leriBool && rileBool;
      }
    ```

#### 二叉树的diff算法
   比较二叉树的改变，是否进行了增删改，如果有就记录下来
 ```js
   // {type: 增/删/改, origin: 原来的, now: 现在的}
   let diffList = [];
   let diffTree = (root1, root2, diffList) => {
       if (root1 === root2) {
           return diffList
       };
       if (root1 === null && root2 !== null) {
           diffList.push({
               type: '新增',
               origin: null,
               now: root2
           });
       } else if (root1 !== null && root2 === null) {
           diffList.push({
               type: '删除',
               origin: root1,
               now: null
           })
       } else if (root1.value !== root2.value) {
           diffList.push({
               type: '修改',
               origin: root1,
               now: root2
           })
           diffTree(root1.left, root2.left, diffList);
           diffTree(root1.right, root2.right, diffList);
       } else {
           diffTree(root1.left, root2.left, diffList);
           diffTree(root1.right, root2.right, diffList);
       }
   }
 ```

### 最小生成树

   树形结构是有向无环图，以最小的代价连接所有的节点，生成最小的树，更能节省空间和效能，也就是查找一个顶点到另一个顶点的最短路径

#### 普利姆算法(加点法)
   
   1. 任选一个顶点作为起点
   2. 找到以当前选中点为起点路径最短的边
   3. 如果这个边的另一端没有被连通，则连接
   4. 如果这个边的另一端也已经被连接起来了，则看倒数第二短的边
   5. 重复2-4直到所有的点都连通为止
  ```js
   let max = 1000000;
   let pointSet = [];
   let distance = [
       [0, 4, 7, max, max],
       [4, 0, 8, 6, max],
       [7, 8, 0, 5, max],
       [max, 6, 5, 0, 7],
       [max, max, max, 7, 0]
   ];
   class Node {    
       constructor(value) {
           this.value = value;
           this.neighbor = [];
       }
   }
   let a = new Node('A');
   let b = new Node('B');
   let c = new Node('C');
   let d = new Node('D');
   let e = new Node('E');
   pointSet.push(a);
   pointSet.push(b);
   pointSet.push(c);
   pointSet.push(d);
   pointSet.push(e);
   let getIndex = (str) => {
       for(let i = 0; i < pointSet.length; i ++) {
           if(pointSet[i].value === str) {
               return i;
           }
       }
       return -1
   }
   //传入顶点的集合，边的数据集合，当前已经连接的顶点的集合
   //根据当前已有的节点进行判断，获取到距离最短的点
   let getMinDisNode = (pointSet, distance, nowPointSet) => {
       let fromNode = null;   //线段的起点
       let minDisNode = null; //线段的终点
       let minDis = max;      //线段的长度，起始为最大值
       for(let i = 0; i < nowPointSet.length; i ++) {
           let nowPointIndex = getIndex(nowPointSet[i].value); //获取当前顶点的索引
           for(let j = 0; j < distance[nowPointIndex].length; j ++) {
               let thisNode = pointSet[j]; //thisNode表示distance中的点，但这个点不是对象，是数据集合
               // 这个点不能是已经接入的点，点之间的距离是最短距离
               if(nowPointSet.indexOf(thisNode) < 0 && distance[nowPointIndex][j] < minDis) {
                   fromNode = nowPointSet[i];
                   minDisNode = thisNode;
                   minDis = distance[nowPointIndex][j];
               }
           }
       }
       fromNode.neighbor.push(minDisNode);
       minDisNode.neighbor.push(fromNode);
       return minDisNode;
   }
   let prim = (pointSet, distance, start) => {
       let nowPointSet = [];
       nowPointSet.push(start);
       //获取最小代价的边
       while(true) {
           let minDisNode = getMinDisNode(pointSet, distance, nowPointSet);
           nowPointSet.push(minDisNode);
           if(nowPointSet.length === pointSet.length) {
               break;
           }
       }
   }   
   prim(pointSet,distance, pointSet[2]);
   console.log(pointSet);
  ``` 


#### 克鲁斯卡尔算法(加边法)

   1. 选择最短的边进行连接
   2. 要保证连接的两端至少有一个点是新的点
   3. 或者 这个边是将两个部落连接到一起(部落：已经连接的一部分顶点； 部落连接：将散落的部落连接在一块形成大部落)
   4. 重复1-3直到所有的点都连接到一起
 ```js
   let max = 1000000;
   let pointSet = [];
   let distance = [
       [0, 4, 7, max, max],
       [4, 0, 8, 6, max],
       [7, 8, 0, 5, max],
       [max, 6, 5, 0, 7],
       [max, max, max, 7, 0]
   ];
   
   class Node {
       constructor(value) {
           this.value = value;
           this.neighbor = [];
       }
   }
   
   let a = new Node('A');
   let b = new Node('B');
   let c = new Node('C');
   let d = new Node('D');
   let e = new Node('E');
   pointSet.push(a);
   pointSet.push(b);
   pointSet.push(c);
   pointSet.push(d);
   pointSet.push(e);
   
   let canLink = (resultList, tempBegin, tempEnd) => {
       let beginIn = null;
       let endIn = null;
       for(let i = 0; i < resultList.length; i ++) {
           if(resultList[i].indexOf(tempBegin) > -1) {
               beginIn = resultList[i];
           }
           if(resultList[i].indexOf(tempEnd) > -1) {
               endIn = resultList[i];
           }
       }
       if (beginIn !== null && endIn !== null && beginIn === endIn) {
           return false;
       }
       return true;
   }
   let Link = (resultList, tempBegin, tempEnd) => {
       let beginIn = null;
       let endIn = null;
       for(let i = 0; i < resultList.length; i ++) {
           if(resultList[i].indexOf(tempBegin) > -1) {
               beginIn = resultList[i];
           }
           if(resultList[i].indexOf(tempEnd) > -1) {
               endIn = resultList[i];
           }
       }
       if(beginIn === null && endIn === null) { //两个点都是新的点，都不在任何部落里，可以连接，产生新的部落
           let newArr = [];
           newArr.push(tempBegin);
           newArr.push(tempEnd);
           resultList.push(newArr);
       } else if(beginIn !== null && endIn === null) {//end有部落，begin没有，end扩张
           beginIn.push(tempEnd);
       } else if(beginIn === null && endIn !== null) {//begin有部落，end没有，begin扩张
           endIn.push(tempBegin);
       } else if(beginIn !== null && endIn !== null && beginIn !== endIn){//两个不同的部落，进行合并   
           let allIn = beginIn.concat(endIn);
           let needRemove = resultList.indexOf(endIn);
           resultList.splice(needRemove, 1);
           needRemove = resultList.indexOf(beginIn);
           resultList.splice(needRemove, 1);
           resultList.push(allIn);
           
       }
       tempBegin.neighbor.push(tempEnd);
       tempEnd.neighbor.push(tempBegin);
   }
   let kruskall = (pointSet, distance) => {
       let resultList = []; //二维数组，此数组代表有多少个部落
       while (true) {
           let minDis = max;
           let begin = null;
           let end = null;
           for (let i = 0; i < distance.length; i++) {
               for (let j = 0; j < distance[i].length; j++) {
                   let tempBegin = pointSet[i];
                   let tempEnd = pointSet[j];
                   // console.log("===========================")
                   // console.log(resultList) 
                   if(i != j && distance[i][j] < minDis && canLink(resultList, tempBegin, tempEnd)) { //去掉自己到自己的距离，因为都为0
                       minDis = distance[i][j];
                       begin = tempBegin;
                       end = tempEnd;
                   }
               }
           }
           Link(resultList, begin, end);
           if(resultList.length === 1 && resultList[0].length === pointSet.length) { //只存在一个部落
               break;
           }
       }
   }
   kruskall(pointSet, distance);
   console.log(pointSet);
 ```
