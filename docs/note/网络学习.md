[toc]

# 网络
 
 计算机相关知识：
    冯诺依曼式计算机--冯诺依曼（计算机之父）
    运算器:  CPU, GPU（显卡）
    存储器:  内存（断电数据清空, 读写速度快）
            硬盘（辅存）:（数据可以持久化，读写速度相对较慢）
            控制器：主板上的⼀些器件
            输⼊设备：键盘，⿏标，⻨克风，⽹口
            输出设备：显示器，耳机，⽹口

## IP地址

 1. IP地址的格式：
    IP地址分为四个段：xxx.xxx.xxx.xxx，每个段0~255，每个段都是由8个0、1组成的。
    
 2. IP地址的分类：
    一个IP地址分为两个部分：⽹络ID，主机ID 
        A类：0.0.0.0 ~ 127.255.255.255（⼀一个⽹络能有1600+万台）
        B类：128.0.0.0 ~ 191.255.255.255（172.16.0.0 ~ 172.31.255.255）
        C类：192.0.0.0 ~ 223.255.255.255（192.168.xxx.xxx）(个人设备多为这个段内)
        D类：（多播地址）
        E类：

## DNS域名解析

 1. 域名与DNS解析
        www.baidu.com->域名
        问：能通过域名直接访问到⼀一台机器器吗？
        答：不可以。⽤域名和IP形成对应关系。首先，计算机是不知道域名对应的IP的。问路由器，如果路由器认识这个域名，就返回一个IP，然后计算机访问这个IP。如果路由器不认识，他就问上一层路由器。如果问到了城市这个级别的路由器的时候(DNS服务器)，如果DNS服务器不认识这个域名，继续向上级DNS服务器查找。
        互联⽹在建立的时候，共有13台总的DNS服务器。

 2. 当向浏览器的地址栏中输⼊⼀个url按回车之后，⽹络中都会发⽣什么？
   
    ⽐如输入的是123.xyz，看浏览器的缓存。本机host。C:windows/system32/drivers/etc/host 127.0.0.1 localhost 0.0.0.0 家里路由器、上级路由、城市的LDNS服务器，继续向上级的DNS服务器找，gDNS服务器器。


## 五层网络模型

 1. 应用层
    HTTP协议、DNS协议
 2. 运输层
    TCP协议、UDP协议
 3. 网络层
    IP地址--IP协议
 4. 数据链路层
    mac地址
 5. 物理层

    TCP/IP协议（对⽅的IP，⾃⼰的IP，对⽅的端⼝） 
    HTTP协议分为两个部分：
        请求：Request 
        请求⽅式：路径协议版本(GET，POST)
        响应：Response

## Get和Post请求方式的区别

 1. 是基于什么前提的？如果什么前提都没有，不使⽤任何规范，只考虑语法和理论上的HTTP协议，则GET和POST⼏乎没有什么区别，只有名字不一样。
 2. 如果是基于RFC规范的。
    1. 理论上的（Specification）：GET和POST具有相同语法的，但是有不同的语义。get是⽤来获取数据的，post是⽤来发送数据的，其他⽅面没有区别。
    2. 实现上的（Implementation）：各种浏览器，就是这个规范的实现者。常见的那些不不同：               
       1. GET的数据在URL是可见的。POST请求不显示在URL中。       
       2. GET对⻓度是有限制的，POST长度是无限的。     
       3. GET请求的数据可以收藏为书签，post请求到的数据不可收藏为书签。 
       4. GET请求后，按后退按钮、刷新按钮无影响，post数据会被重新提交。  
       5. GET编码类型：application/x-www-form-url，post的编码类型：有很多种：encodeapplication/x-www-form-urlencoded    multipart/form-data        
       6. GET历史参数会被保留在浏览器里，psot不会保存在浏览器中的。   
       7. GET只允许ASCII，post没有编码限制，允许发二进制的。        
       8. GET与POST相比，GET安全性较差，因为所发的数据是URL的⼀部分。


## Cookie与Session

 1. 如果我们用JS的变量来存数据，那么在⻚面关闭的时候，数据就消失了。
 2. 保持登录状态是怎么做到的呢？按照正常的HTTP协议来说，是做不到的。因为HTTP协议，上下文无关协议。
 3. 所以说前端⻚面上，有可以持久化存储数据的东西。⼀旦登录成功，我就记载在这个⾥面。
 4. Cookie是有限制的。Cookie是存在浏览器里的，不是存在某个⻚面上的。是可以⻓期存储的。Cookie即使是保存在浏览器里，也是存放在不同的域名下的。
   1. 初始状态：没有登录
   2. 访问百度的登录，输⼊用户名，密码。
   3. 如果⽤户名和密码是正确的。百度的后端会向这个域名下，设置⼀个Cookie。写入⽤户的基本信息（加密的）。
   4. 以后每⼀次向百度发送请求，浏览器都会自动带上这些Cookie。
   5. 服务端（后端）看到了带有ID的cookie，就可以解析这个加密的ID，来获取到这个用户本身的ID。
   6. 如果能获取到本身的ID，那么就证明这个⽤户已经登录过了。所以后端可以继续保留用户的信息。
      1. 缺点：如果某个坏人，复制了我浏览器里的cookie，他就可以在他的电脑上登录我的账号了。
      2. XSS注入攻击。

 Session指信息存储在服务端，数据存在Session上也有缺点，如果⽤户量⾮常大，上亿的用户。在用户量很大的时候，服务器端很耗资源的。因为后端可能不止一台服务器，用户的登录信息，⼀般只存在一台服务器上。因为用户的登录操作，在哪台机器上执行的，就一般存在哪台机器上。需要通过反向代理。（轮询，IP哈希。）

 服务器：严格的说，服务器是一台计算机，这台计算机，只提供服务。（不是⽤户用的）但是，我们常说的这个服务器，指的是服务容器，不是服务器。
 服务容器：是⼀个程序。程序可以监听⼀个端口。读取文件，并且返回。如果我们想通过访问服务器（服务容器）的方式，来访问我们自己写的⻚面。我们就得装一个服务容器的程序。


## B/S结构和C/S结构

 1. Client/Server——Client,只负责内容的展示，Server负责提供内容。
 2. Browser/Server——Browser只负责内容的展示，Server负责提供内容。

 index.html ⻚面的本质是什么？
    ⻚面的本质就是⼀个字符串。带有HTML格式的字符串。

 浏览器向服务器请求⼀个⻚面的本质是什么？
    1）www.baidu.com
    2）服务器接收到这个请求后，服务器想要把这个⻚面的内容（HTML格式的字符串）返回给浏览器。
    3）⻚面的字符串存在HTML⽂件里。例如：index.html 
    4）服务器端要读取文件。
    5）将读取出来的内容返回给浏览器。最后返回的是一个字符串，这个字符串的来源可能是文件，可能是缓存，可能来自于数据库。

## 跨域
 
 哪些东西属于资源？
    js文件肯定是算资源的，但是js文件是允许被跨域请求的。css文件，jpg,png等src属性的资源都是可以被跨域请求的, href资源大部分也都是可以被跨域请求的。

 哪些资源算跨域请求的资源？
    1.后端接口的数据。
    2.其它域的cookie 
    3.其它域的缓存

 什么是其它的域？怎么样算跨域？
    页面本身：有协议（http/https）,域名，端口，要请求的数据，协议，域名，端口这三个，有任意一个不一样就算跨域。

 跨域这个行为，发生在哪里?
    1.即使跨域了（协议，域名，端口号有不一样的），请求也可以发出。
    2.服务器端也是可以接收的。
    3.服务器端也是可以正常处理的。
    4.服务器端也是可以正常返回数据。
    5.浏览器也能接收到这些数据。
    6.接收到之后，发现当前⻚面的域和请求的域不同，所以判定为跨域。
    7.我们的代码在这等着结果呢，但是因为浏览器判定跨域了，不会把结果传递给我们的代码。

 虽然跨域了，但是我们依然需要这个数据，怎么办？
    1.后端（别⼈家的）配合我们进行跨域。pan.baidu.com  ——> zhidao.baidu.com
        （1）JSONP（正常的情况，返回的数据都是JSON格式。JSONP是一种特殊的格式。）
        （2）后端设置Access-Control-Allow-Origin属性以支持跨域。
    2. 后端不配合我们进行跨域。
        （3）iframe（只能显示，不能控制）
        （4）通过后端代理（⾃己的后端）

## 发送网络请求的几种方式

 1. 在浏览器中直接输入网址（无法用代码控制）

 2. location.href = "url"，可以发出请求，但是页面会发生跳转

 3. （差边球，如果只发出不返回可以用用，如img或script标签）带有src属性的标签，请求是可以发出的，服务端是可以处理的，也是可以返回的，但返回之后能否被应用还要看浏览器，页面无法处理返回结果

 4. 带有href属性的标签（link等），请求是可以发出的，服务端是可以处理的，也是可以返回的，但是返回之后能否被应用，还要看浏览器，页面无法处理返回结果

 5. 带有action属性的标签（form表单等），也可以向后端发出请求，但form表单发出请求之后，也会发生页面跳转

 6. ajax发送请求
    可以用代码控制，页面不会跳转，服务端返回的结果可以用js继续处理
    要素：
    1. 请求方式：'get','post'等
    2. url
    3. 原生js ajax：
    ```js
       var xhr = null;
       if(window.XMLHttpRequest){
           xhr = new XMLHttpRequest();
           //IE6及以下浏览器不适配
       } else{
           xhr = new ActiveXObject("Microsoft.XmlHttp");
           //IE6及以下浏览器使用
       }
       console.log(xhr.readyState);
       xhr.open("get","http://daveloper.duyiedu.com/edu/testAjaxCrossOrigin",true);
       //第三个参数代表同步还是异步，true表示异步，false表示同步，默认为true
       console.log(xhr.readyState);
       xhr.onreadystatechange = function (){
           //readyState === 4 表示请求完成，已经接收到数据
           //status === 200 网络请求，结果都会有一个状态码，来表示这个请求是否正常（可以去菜鸟教程查看http状态码）
           //200表示请求成功
           //http状态码：
           //2**表示请求成功
           //3**表示重定向，就是后端端口口改变，访问原接口会回馈现在接口的端口号
           //4**表示客户端错误，404表示页面没找到，也就是url错误
           //5**表示服务端错误，后端代码出错等问题，后端的问题

           if(xhr.readyState === 4 && xhr.status === 200){
               console.log(xhr.responseText);
               var data = JSON.parse(xhr.responseText);
               console.log(data);
           }
       }
       xhr.send();
    ```

    4. jQuery模式下的ajax的josnp
    ```js
       //jsonp哪里特殊？
       //发送的时候，会带上一个参数：callback
       //返回的结果不是json，而是callback的名 + "(" + json + ")";
       $.ajax({
           url:"http://daveloper.duyiedu.com/edu/testJSonp",
           type:"get",
           dataType:"jsonp",
           success:function(data){
               console.log(data);
           }
       })
       //jsonp跨域，只能使用get方法，如果我们设置的是post方法，jquery会自动转为get方法
       //但不是说在jsonp里只能使用get方法，我们设置的post方法也不是都会转换为get方法
       //jquery会先判断是否同源，如果同源，则设置的是get就是get，设置的是post就是post；如果不同源，无论设置什么，都改为get

    ```

    1. jsonp的原理
    ```js
       //jsonp原理
       //因为我想从一个接口获取一个数据，但是这个接口和当前页面不是同源的，也就是跨域了，但是这个接口又是支持JSONP的
       //script标签有src属性，所以可以发出网络请求，但虽然可以引用其他域的资源，浏览器不限制，但浏览器会将其返回的内容作为js代码执行
       //此时调用回调函数，其参数就是请求得到的数据

       //asd({"a":"ok","b":"hello"})
       //相当于调用asd方法，传入一个json对象作为参数

       // 1.判断请求与当前页面的域是否同源，如果同源则发送正常的ajax，就没有跨域的事情了
       // 2.如果不同源，生成一个script标签
       // 3.生成一个随机的callback函数名字，并创建一个名为这个名字的方法（函数）
       // 4.设置script标签的src，设置为要请求的接口
       // 5.将callback作为参数拼接在后面
       // ============以上是前端部分============
       // 6.后端接收到请求后，开始准备要返回的数据
       // 7.后端拼接数据，将要返回的数据用callback的值和括号包裹起来
       //          例如：callback = asd123， 要返回的数据为{"a":1,"b":2}
       //          就要拼接为：asd123({"a":1,"b":2})
       // 8.将内容返回
       // ============以上是后端部分============
       // 9.浏览器接收到内容，会当做js代码来执行
       // 10.从而执行名为asd123的方法，json为其参数，这样我们就接收到了后端返回给我们的对象了

       var $ = {
           ajax: function (options) {
               var url = options.url,
               type = options.type,
               dataType = options.dataType;
               //判断是否同源（协议，域名，端口号）
               //获取目标url的域
               var targetProtocol = "";//目标接口的协议
               var targetHost = "";//目标接口的host，host是包涵域名和端口的
               //如果url不带http，那么访问的一定是相对路径，相对路径一定是同源的。
               if (url.indexOf("http://") == 0 || url.indexOf("https://") == 0) {
                   var targetUrl = new URL(url);
                   targetProtocol = targetUrl.protocol;
                   targetHost = targetUrl.host;
               } else {
                   targetProtocol = location.protocol;
                   targetHost = location.host;
               }
               //首先判断是否为jsonp，因为不是jsonp不用做其他的判断，直接发送ajax
               if (dataType == "jsonp") {
                   //要看是否同源
                   if (location.protocol == targetProtocol && location.host == targetHost) {//表示同源
                       //此处省略。因为同源，jsonp会当做普通的ajax做请求
                   } else {//不同源，跨域
                       //随机生成一个callback
                       var callback = "cb" + Math.floor(Math.random() * 1000000);
                       //给window上添加一个方法
                       window[callback] = options.success;
                       //生成script标签。
                       var script = document.createElement("script");
                       if (url.indexOf("?") > 0) {//表示已经有参数了
                           script.src = url + "&callback=" + callback;
                       } else {//表示没有参数
                           script.src = url + "?callback=" + callback;
                       }
                       script.id = callback;
                       document.head.appendChild(script);
                   }
               }
           }
       }

       //http://developer.duyiedu.com/edu/testJsonp?callback

       $.ajax({
           url: "http://developer.duyiedu.com/edu/testJsonp",
           type: "get",
           dataType: "jsonp",
           success: function (data) {
               console.log(data);
           }
       });
    ```

## HTTP请求状态码
    主要包括：1*，2*，3*，4*以及5*，具体如下：

    1*（临时响应）
         表示临时响应并需要请求者继续执行操作的状态代码。
         100（继续）:请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。   
         101（切换协议）:请求者已要求服务器切换协议，服务器已确认并准备切换。

    2*（成功）
         表示成功处理了请求的状态代码
         200（成功）: 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。  
         201（已创建）: 请求成功并且服务器创建了新的资源。  
         202（已接受）: 服务器已接受请求，但尚未处理。  
         203（非授权信息）: 服务器已成功处理了请求，但返回的信息可能来自另一来源。  
         204（无内容）: 服务器成功处理了请求，但没有返回任何内容。  
         205（重置内容）:服务器成功处理了请求，但没有返回任何内容。  
         206（部分内容）: 服务器成功处理了部分 GET 请求。

    3*（重定向）
         表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向
         300（多种选择）: 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。  
         301（永久移动）: 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。  
         302（临时移动）: 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。  
         303（查看其他位置）:请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。  
         304（未修改）:自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。  
         305（使用代理）:请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。  
         307（临时重定向）: 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。

    4*（客户端请求错误）
         表示请求可能出错，妨碍了服务器的处理
         400（错误请求）:服务器不理解请求的语法。  
         401（未授权）:请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。  
         403（禁止）:服务器拒绝请求。  
         404（未找到）:服务器找不到请求的网页。  
         405（方法禁用）:禁用请求中指定的方法。  
         406（不接受）:无法使用请求的内容特性响应请求的网页。  
         407（需要代理授权）:此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。  
         408（请求超时）: 服务器等候请求时发生超时。  
         409（冲突）: 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。  
         410（已删除）: 如果请求的资源已永久删除，服务器就会返回此响应。  
         411（需要有效长度）:服务器不接受不含有效内容长度标头字段的请求。  
         412（未满足前提条件）:服务器未满足请求者在请求中设置的其中一个前提条件。  
         413（请求实体过大）:服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。  
         414（请求的 URI 过长）:请求的 URI（通常为网址）过长，服务器无法处理。  
         415（不支持的媒体类型）:请求的格式不受请求页面的支持。  
         416（请求范围不符合要求）:如果页面无法提供请求的范围，则服务器会返回此状态代码。  
         417（未满足期望值）:服务器未满足”期望”请求标头字段的要求。

    5*（服务器内部错误）
         表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错
         500（服务器内部错误）: 服务器遇到错误，无法完成请求。  
         501（尚未实施）:服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。  
         502（错误网关）:服务器作为网关或代理，从上游服务器收到无效响应。  
         503（服务不可用）:服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。  
         504（网关超时）: 服务器作为网关或代理，但是没有及时从上游服务器收到请求。  
         505（HTTP 版本不受支持）:服务器不支持请求中所用的 HTTP 协议版本。