# 网络

- 计算机相关知识：
  - 冯诺依曼式计算机--冯诺依曼（计算机之父）
    - 运算器:  CPU, GPU（显卡）
    - 存储器:  内存（断电数据清空, 读写速度快）
    - 硬盘（辅存）:（数据可以持久化，读写速度相对较慢）
    - 控制器：主板上的⼀些器件
    - 输⼊设备：键盘，⿏标，⻨克风，⽹口
    - 输出设备：显示器，耳机，⽹口

## IP地址

-  IP地址的格式：
   - IP地址分为四个段：xxx.xxx.xxx.xxx，每个段0~255，每个段都是由8个0、1组成的。 
-  IP地址的分类：
   - 一个IP地址分为两个部分：⽹络ID，主机ID
   - A类：0.0.0.0 ~ 127.255.255.255（⼀一个⽹络能有1600+万台）
   - B类：128.0.0.0 ~ 191.255.255.255（172.16.0.0 ~ 172.31.255.255）
   - C类：192.0.0.0 ~ 223.255.255.255（192.168.xxx.xxx）(个人设备多为这个段内)
   - D类：（多播地址）
   - E类： 

## DNS域名解析

-  域名与DNS解析
   - www.baidu.com->域名
   - **能通过域名直接访问到一台机器吗？**
     - 不可以
     - 域名和IP形成对应关系
     - 首先，计算机是不知道域名对应的IP的，会先问路由器，如果路由器认识这个域名，就返回一个IP，然后计算机访问这个IP
     - 如果路由器不认识，他就问上一层路由器
     - 问到了城市这个级别的路由器的时候(DNS服务器)，如果DNS服务器不认识这个域名，继续向上级DNS服务器查找
     - 互联⽹在建立的时候，共有13台总的DNS服务器 
   - 当向浏览器的地址栏中输⼊⼀个url按回车之后，⽹络中都会发⽣什么？
     - ⽐如输入的是123.xyz，会先看浏览器是否有缓存
     - 然后查询家里路由器、上级路由、城市的LDNS服务器
     - 如果还没找到，继续向上级的DNS服务器找，直到gDNS服务器 

## 五层网络模型

-  应用层
   - HTTP协议、DNS协议 
-  运输层
   - TCP协议、UDP协议 
-  网络层
   - IP地址--IP协议 
-  数据链路层
   - mac地址 
-  物理层
   - TCP/IP协议（对⽅的IP，⾃⼰的IP，对⽅的端⼝）
-  HTTP协议分为两个部分：
   - 请求：Request
     - 请求⽅式：路径协议版本(GET，POST)
   - 响应：Response 

## Get和Post请求方式的区别

- 是基于什么前提的？如果什么前提都没有，不使⽤任何规范，只考虑语法和理论上的HTTP协议，则GET和POST⼏乎没有什么区别，只有名字不一样
- 如果是基于RFC规范的
  - 理论上的（Specification）：GET和POST具有相同语法的，但是有不同的语义
    - get是用来获取数据的，post是用来发送数据的，其他方面没有区别
  - 实现上的（Implementation）：各种浏览器，就是这个规范的实现者，常见的那些不同： 
    - GET的数据在URL是可见的，POST请求不显示在URL中
    - GET对长度是有限制的，POST长度是无限的
    - GET请求的数据可以收藏为书签，post请求到的数据不可收藏为书签
    - GET请求后，按后退按钮、刷新按钮无影响，post数据会被重新提交
    - GET编码类型：application/x-www-form-url，post的编码类型：有很多种：encodeapplication/x-www-form-urlencoded    multipart/form-data
    - GET历史参数会被保留在浏览器里，psot不会保存在浏览器中的
    - GET只允许 ASCII 编码，POST没有编码限制，允许发二进制的
    - GET与POST相比，GET安全性较差，因为所发的数据是URL的⼀部分

## Cookie与Session

- 如果我们用JS的变量来存数据，那么在⻚面关闭的时候，数据就消失了
  - 保持登录状态是怎么做到的呢？按照正常的HTTP协议来说，是做不到的。因为HTTP协议是上下文无关协议
  - 所以说前端⻚面上，有可以持久化存储数据的东西。⼀旦登录成功，我就记载在这个⾥面

### Cookie

- Cookie是有限制的
- Cookie是存在浏览器里的，不是存在某个⻚面上的，是可以⻓期存储的
- Cookie即使是保存在浏览器里，也是存放在不同的域名下的
  - 比如在初始状态时是没有登录的
  - 访问百度的登录，输⼊用户名，密码
  - 如果⽤户名和密码是正确的，百度的后端会向这个域名下，设置⼀个Cookie，写入⽤户的基本信息（加密的）
  - 以后每⼀次向百度发送请求，浏览器都会自动带上这些Cookie
  - 服务端（后端）看到了带有ID的cookie，就可以解析这个加密的ID，来获取到这个用户本身的ID
  - 如果能获取到本身的ID，那么就证明这个⽤户已经登录过了，所以后端可以继续保留用户的信息
- 缺点：
  - 如果某个坏人，复制了我浏览器里的cookie，他就可以在他的电脑上登录我的账号了
  - XSS注入攻击

### Session

- Session指信息存储在服务端
  - 数据存在Session上也有缺点，如果⽤户量⾮常大，上亿的用户
  - 在用户量很大的时候，服务器端很耗资源的
  - 因为后端可能不止一台服务器，用户的登录信息，⼀般只存在一台服务器上，用户的登录操作，在哪台机器上执行的，就一般存在哪台机器上
  - 需要通过反向代理（轮询，IP哈希）
- 服务器
  - 严格的说，服务器是一台计算机，这台计算机，只提供服务（不是⽤户用的）
  - 但是，我们常说的这个服务器，指的是服务容器，不是服务器
    - 服务容器：是⼀个程序
      - 程序可以监听⼀个端口，读取文件，并且返回
      - 如果我们想通过访问服务器（服务容器）的方式，来访问我们自己写的⻚面，我们就得装一个服务容器的程序

## 跨域

### 可以被跨域请求的资源

- js文件
- css文件
- jpg、png 等 src 属性的资源
- 大部分 href 资源

### 不允许跨域请求的资源

- 后端接口的数据
- 其它域的cookie
- 其它域的缓存

### 什么是其它的域？怎么样算跨域？

url 本身：

- 有协议（http/https）,域名，端口，要请求的数据
- 协议，域名，端口有任意一个不一样就算跨域

#### 跨域这个行为，发生在哪里?

- 即使跨域了（协议，域名，端口号有不一样的），请求也可以发出
- 服务器端也是可以接收的
- 服务器端也是可以正常处理的
- 服务器端也是可以正常返回数据
- 浏览器也能接收到这些数据
- 接收到之后，发现当前⻚面的域和请求的域不同，所以判定为跨域
- 我们的代码在这等着结果呢，但是因为浏览器判定跨域了，不会把结果传递给我们的代码

#### 虽然跨域了，但是我们依然需要这个数据，怎么办？

- 后端（别⼈家的）配合我们进行跨域
  - JSONP（正常的情况，返回的数据都是JSON格式。JSONP是一种特殊的格式
  - 后端设置Access-Control-Allow-Origin属性以支持跨域。
- 后端不配合我们进行跨域
  - iframe（只能显示，不能控制）
  - 通过后端代理（⾃己的后端）

### 跨域的解决办法

- CORS: (Cross-Origin Resource Sharing)基于服务器支持的跨域，服务器设置Access-Control-Allow-Origin响应头，浏览器可允许跨域
- 服务器代理
- 设置domain
  - 能从子域设到主域，如a.b.c.com—>b.c.com—>c.com 
  - 具体情况：
    - 在页面中用iframe打开了另一个页面（前提：两个页面主域是相同的）
    - 利用frameElement.contentWindow.document.domain设置frame子页面的主域
    - document.domain设置主页面的主域，之后就能互相获取dom中的数据
    - 缺点是只能用于不同子域间的交互
- img的src：拥有src属性的img标签，每次改变src属性，都会发起http请求，常用于埋点需求
- postMessage

```javascript
var win = window.open("http://target.com");
var win = document.getElementById("targetId").contentWindow;
win.postMessage("data here", "http://target.com/rest");
function handleMessage(event){
if(event.orgin!="http://test.org:4000")
return;
var data = event.data;
event.source.postMessage("response data here", event.origin);
}
window.addEventListener("message", handleMessage, false);
```

- window.name
  - 即使在页面打开多层iframe后，每个iframe中window.name 属性值都是相同的，以此用作数据传输的工具
  - 但由于跨域的限制，是无法获取另一个frame中的window.name数据，所以要使用一个同域的代理(proxy.html)
- jsonp：只能获取get请求
- nginx代理

#### jsonp的理解

- jsonp是一种非官方跨域数据交互协议，它允许在服务器端集成< script >标签返回至客户端，通过javascript回调的形式实现跨域访问
- 因为同源策略的原因，我们不能使用XMLHttpRequest与外部服务器进行通信，但是< script >可以访问外部资源，所以通过JSON与< script >相结合的办法，可以绕过同源策略从外部服务器直接取得可执行的JavaScript函数

**原理**

- 客户端定义一个函数，比如jsonpCallback
- 然后创建< script >，src 为`url + ?jsonp=jsonpCallback`这样的形式
- 之后服务器会生成一个和传递过来jsonpCallback一样名字的参数，并把需要传递的数据当做参数传入
- 比如jsonpCallback(json)，然后返回给客户端
- 此时客户端就执行了这个服务器端返回的jsonpCallback(json)回调

**优缺点**

- 优点
  - 兼容性好
  - 简单易用
  - 支持浏览器与服务器双向通信 
- 缺点
  - 只支持GET请求
  - 存在脚本注入以及跨站请求伪造等安全问题

**注意：JSONP不使用XMLHttpRequest对象加载资源，不属于真正意义上的AJAX**

## 发送网络请求的几种方式

- 在浏览器中直接输入网址（无法用代码控制） 
- `location.href = "url"`，可以发出请求，但是页面会发生跳转 
- 带有src属性的标签，请求是可以发出的，服务端是可以处理的，也是可以返回的，但返回之后能否被应用还要看浏览器，页面无法处理返回结果 （差边球，如果只发出不返回可以用来玩玩，如img或script标签，工作中不要使用）
- 带有href属性的标签（link等），请求是可以发出的，服务端是可以处理的，也是可以返回的，但是返回之后能否被应用，还要看浏览器，页面无法处理返回结果 
- 带有action属性的标签（form表单等），也可以向后端发出请求，但form表单发出请求之后，也会发生页面跳转 
- ajax发送请求
  - 可以用代码控制，页面不会跳转，服务端返回的结果可以用js继续处理
  - 要素： 
    - 请求方式：'get'、'post'等
    - url
    - 原生js ajax：

```javascript
var xhr = null;
if(window.XMLHttpRequest){
  xhr = new XMLHttpRequest();
  //IE6及以下浏览器不适配
} else{
  xhr = new ActiveXObject("Microsoft.XmlHttp");
  //IE6及以下浏览器使用
}
console.log(xhr.readyState);
xhr.open("get","http://daveloper.duyiedu.com/edu/testAjaxCrossOrigin",true);
//第三个参数代表同步还是异步，true表示异步，false表示同步，默认为true
console.log(xhr.readyState);
xhr.onreadystatechange = function (){
  //readyState === 4 表示请求完成，已经接收到数据
  //status === 200 网络请求，结果都会有一个状态码，来表示这个请求是否正常（可以去菜鸟教程查看http状态码）
  //200表示请求成功
  //http状态码：
  //2**表示请求成功
  //3**表示重定向，就是后端端口口改变，访问原接口会回馈现在接口的端口号
  //4**表示客户端错误，404表示页面没找到，也就是url错误
  //5**表示服务端错误，后端代码出错等问题，后端的问题
  if(xhr.readyState === 4 && xhr.status === 200){
    console.log(xhr.responseText);
    var data = JSON.parse(xhr.responseText);
    console.log(data);
  }
}
xhr.send();
```

   - jQuery模式下的ajax的josnp

```javascript
//jsonp哪里特殊？
//发送的时候，会带上一个参数：callback
//返回的结果不是json，而是callback的名 + "(" + json + ")";
$.ajax({
  url:"http://daveloper.duyiedu.com/edu/testJSonp",
  type:"get",
  dataType:"jsonp",
  success:function(data){
    console.log(data);
  }
})
//jsonp跨域，只能使用get方法，如果我们设置的是post方法，jquery会自动转为get方法
//但不是说在jsonp里只能使用get方法，我们设置的post方法也不是都会转换为get方法
//jquery会先判断是否同源，如果同源，则设置的是get就是get，设置的是post就是post；如果不同源，无论设置什么，都改为get
```

   - jsonp的原理

```javascript
//jsonp原理
//因为我想从一个接口获取一个数据，但是这个接口和当前页面不是同源的，也就是跨域了，但是这个接口又是支持JSONP的
//script标签有src属性，所以可以发出网络请求，但虽然可以引用其他域的资源，浏览器不限制，但浏览器会将其返回的内容作为js代码执行
//此时调用回调函数，其参数就是请求得到的数据

//asd({"a":"ok","b":"hello"})
//相当于调用asd方法，传入一个json对象作为参数

// 1.判断请求与当前页面的域是否同源，如果同源则发送正常的ajax，就没有跨域的事情了
// 2.如果不同源，生成一个script标签
// 3.生成一个随机的callback函数名字，并创建一个名为这个名字的方法（函数）
// 4.设置script标签的src，设置为要请求的接口
// 5.将callback作为参数拼接在后面
// ============以上是前端部分============
// 6.后端接收到请求后，开始准备要返回的数据
// 7.后端拼接数据，将要返回的数据用callback的值和括号包裹起来
//          例如：callback = asd123， 要返回的数据为{"a":1,"b":2}
//          就要拼接为：asd123({"a":1,"b":2})
// 8.将内容返回
// ============以上是后端部分============
// 9.浏览器接收到内容，会当做js代码来执行
// 10.从而执行名为asd123的方法，json为其参数，这样我们就接收到了后端返回给我们的对象了
var $ = {
  ajax: function (options) {
    var url = options.url,
        type = options.type,
        dataType = options.dataType;
    //判断是否同源（协议，域名，端口号）
    //获取目标url的域
    var targetProtocol = "";//目标接口的协议
    var targetHost = "";//目标接口的host，host是包涵域名和端口的
    //如果url不带http，那么访问的一定是相对路径，相对路径一定是同源的。
    if (url.indexOf("http://") == 0 || url.indexOf("https://") == 0) {
      var targetUrl = new URL(url);
      targetProtocol = targetUrl.protocol;
      targetHost = targetUrl.host;
    } else {
      targetProtocol = location.protocol;
      targetHost = location.host;
    }
    //首先判断是否为jsonp，因为不是jsonp不用做其他的判断，直接发送ajax
    if (dataType == "jsonp") {
      //要看是否同源
      if (location.protocol == targetProtocol && location.host == targetHost) {//表示同源
        //此处省略。因为同源，jsonp会当做普通的ajax做请求
      } else {//不同源，跨域
        //随机生成一个callback
        var callback = "cb" + Math.floor(Math.random() * 1000000);
        //给window上添加一个方法
        window[callback] = options.success;
        //生成script标签。
        var script = document.createElement("script");
        if (url.indexOf("?") > 0) {//表示已经有参数了
          script.src = url + "&callback=" + callback;
        } else {//表示没有参数
          script.src = url + "?callback=" + callback;
        }
        script.id = callback;
        document.head.appendChild(script);
      }
    }
  }
}
//http://developer.duyiedu.com/edu/testJsonp?callback
$.ajax({
  url: "http://developer.duyiedu.com/edu/testJsonp",
  type: "get",
  dataType: "jsonp",
  success: function (data) {
    console.log(data);
  }
});
```

### ajax的理解和优缺点

- ajax是无须进行刷新页面就可以请求后台的数据的一种方法
- 通过XmlHttpRequest对象来向服务器发送异步请求，从服务器中获取数据
- 然后通过js进行操作dom，以此来更新页面内容

#### 具体实现过程

1. 创建一个XmlHttpRequest的对象
2. 设置响应HTTP请求的回调函数
3. 创建一个HTTP请求，指定响应的请求方法、url、参数等
4. 发送HTTP请求
5. 获取服务端返回的数据
6. 使用js操作dom更新页面的内容

#### 缺点

- 对搜索引擎不友好
- 要实现Ajax下的前进后退功能成本较大
- 跨域问题限制

## HTTP请求状态码

主要包括：1*，2*，3*，4*以及5*，具体如下：

- 1*（临时响应）
  - 表示临时响应并需要请求者继续执行操作的状态代码
  - 100（继续）:请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分
  - 101（切换协议）:请求者已要求服务器切换协议，服务器已确认并准备切换
- 2*（成功）
  - 表示成功处理了请求的状态代码
  - 200（成功）: 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页
  - 201（已创建）: 请求成功并且服务器创建了新的资源
  - 202（已接受）: 服务器已接受请求，但尚未处理
  - 203（非授权信息）: 服务器已成功处理了请求，但返回的信息可能来自另一来源
  - 204（无内容）: 服务器成功处理了请求，但没有返回任何内容
  - 205（重置内容）:服务器成功处理了请求，但没有返回任何内容
  - 206（部分内容）: 服务器成功处理了部分 GET 请求
- 3*（重定向）
  - 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向
  - 300（多种选择）: 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择
  - 301（永久移动）: 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置
  - 302（临时移动）: 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求
  - 303（查看其他位置）:请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码
  - 304（未修改）:自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容
  - 305（使用代理）:请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理
  - 307（临时重定向）: 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求
- 4*（客户端请求错误）
  - 表示请求可能出错，妨碍了服务器的处理
  - 400（错误请求）:服务器不理解请求的语法
  - 401（未授权）:请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应
  - 403（禁止）:服务器拒绝请求
  - 404（未找到）:服务器找不到请求的网页
  - 405（方法禁用）:禁用请求中指定的方法
  - 406（不接受）:无法使用请求的内容特性响应请求的网页
  - 407（需要代理授权）:此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理
  - 408（请求超时）: 服务器等候请求时发生超时
  - 409（冲突）: 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息
  - 410（已删除）: 如果请求的资源已永久删除，服务器就会返回此响应
  - 411（需要有效长度）:服务器不接受不含有效内容长度标头字段的请求
  - 412（未满足前提条件）:服务器未满足请求者在请求中设置的其中一个前提条件
  - 413（请求实体过大）:服务器无法处理请求，因为请求实体过大，超出服务器的处理能力
  - 414（请求的 URI 过长）:请求的 URI（通常为网址）过长，服务器无法处理
  - 415（不支持的媒体类型）:请求的格式不受请求页面的支持
  - 416（请求范围不符合要求）:如果页面无法提供请求的范围，则服务器会返回此状态代码
  - 417（未满足期望值）:服务器未满足”期望”请求标头字段的要求
- 5*（服务器内部错误）
  - 表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错
  - 500（服务器内部错误）: 服务器遇到错误，无法完成请求
  - 501（尚未实施）:服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码
  - 502（错误网关）:服务器作为网关或代理，从上游服务器收到无效响应
  - 503（服务不可用）:服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态
  - 504（网关超时）: 服务器作为网关或代理，但是没有及时从上游服务器收到请求
  - 505（HTTP 版本不受支持）:服务器不支持请求中所用的 HTTP 协议版本

## http和https的区别

- https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用
- http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议
- http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443
- http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全

##  https模式下配置带有cookie的请求头

- 设置cookie的secure属性
  - 当设置为true时，表示创建的 Cookie 会被以安全的形式向服务器传输
  - 也就是只能在 HTTPS 连接中被浏览器传递到服务器端进行会话验证
  - 如果是 HTTP 连接则获取该信息，所以不会被窃取到Cookie 的具体内容
  - 但是这会导致在同一服务器下HTTPS切换到HTTP协议时，HTTP无法访问、修改同名Cookie
  - 所以必须在HTTPS下清除Cookie或者设定Cookie的作用域

##  XSS与CSRF两种跨站攻击区别

- xss跨站脚本攻击，主要是前端层面的
  - 用户在输入层面插入攻击脚本，改变页面的显示，或则窃取网站 cookie
  - 预防方法：不相信用户的所有操作，对用户输入进行一个转义，不允许 js 对 cookie 的读写
- csrf跨站请求伪造攻击
  - 以你的名义，发送恶意请求
  - 通过 cookie 加参数等形式过滤
  - 没法彻底杜绝攻击，只能提高攻击门槛

# 浏览器

## 浏览器的理解

- 用户界面
  - 包括地址栏、后退/前进按钮、书签目录等
  - 也就是所看到的除了用来显示所请求页面的主窗口之外的其他部分
- 浏览器引擎
  - 用来查询及操作渲染引擎的接口
- 渲染引擎
  - 用来显示请求的内容
  - 例如，如果请求内容为html，它负责解析html及css，并将解析后的结果显示出来
- 网络
  - 用来完成网络调用
  - 例如http请求，它具有平台无关的接口，可以在不同平台上工作
- UI后端
  - 用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口
- jS解释器
  - 用来解释执行JS代码
- 数据存储
  - 属于持久层，浏览器需要在硬盘中保存类似cookie的各种数据
  - HTML5定义了web database技术，这是一种轻量级完整的客户端存储技术

## 浏览器从输入一个url到网页展示的整个过程

**具体总结主要为6个步骤**

1. DNS解析：进行域名解析，找到对应的服务ip
2. TCP连接 ：进行三次握手，确保可以进行数据传输
3. 发送HTTP请求：发送具体的请求信息
4. 服务器处理请求并返回HTTP报文：服务器返回详情的内容，具体包括：状态码、响应报头和响应报文
5. 浏览器解析渲染页面：首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树
6. 树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上
7. 连接结束：进行TCP四次挥手，断开TCP连接

## 优化网站性能

- http 请求方面
  - 减少请求数量，请求体积，对应的做法是
    - 对项目资源进行压缩
    - 控制项目资源的 dns 解析在2到4个域名
    - 提取公共样式、公共组件
    - 缓存资源，压缩资源，提取公共资源压缩
    - 提取 css ，js
    - 公共方法不要缩放图片
    - 使用雪碧图
    - 使用字体图表（阿里矢量图库）
    - 使用 CDN
  - 抛开无用的 cookie
  - 减少重绘重排
  - CSS属性读写分离，最好不要用 js 修改样式
  - dom 离线更新，渲染前指定图片的大小
  - js 代码层面的优化
    - 减少对字符串的计算
    - 合理使用闭包
    - 首屏的 js 资源加载放在最底部

## B/S结构和C/S结构

- Client/Server——Client 只负责内容的展示，Server 负责提供内容
- Browser/Server——Browser 只负责内容的展示，Server 负责提供内容

## index.html 页面的本质

**页面的本质就是⼀个字符串，带有HTML格式的字符串**

### 浏览器向服务器请求⼀个页面的本质

- www.baidu.com
- 服务器接收到这个请求后，服务器想要把这个⻚面的内容（HTML格式的字符串）返回给浏览器
- 页面的字符串存在HTML⽂件里，例如：index.html
- 服务器端要读取文件
- 将读取出来的内容返回给浏览器，最后返回的是一个字符串，这个字符串的来源可能是文件，可能是缓存，可能来自于数据库

## dom的重绘和重排

### 重排

- 部分渲染树（或者整个渲染树）需要重新分析并且节点尺寸需要重新计算
- 这样的更新被称为重排
- 至少会有一次重排
  - 初始化页面布局。 

### 重绘

- 由于节点的几何属性发生改变或者由于样式发生改变需要进行页面内容更新
- 例如改变元素背景色时，屏幕上的部分内容需要更新
- 这样的更新被称为重绘

### 造成重排或者重绘的场景

- 添加、删除、更新 DOM 节点
  - 通过 display: none 隐藏一个 DOM 节点，触发重排和重绘
  - 通过 visibility: hidden 隐藏一个 DOM 节点，只触发重绘，因为没有几何变化
- 移动或者给页面中的 DOM 节点添加动画
- 添加一个样式表，调整样式属性
- 用户行为，例如调整窗口大小，改变字号，或者滚动

## js加载的方式 defer/async

- 渲染引擎遇到 script 标签会停下来，等到执行完脚本，继续向下渲染
- defer 是“渲染完再执行”
- async 是“下载完就执行”
- defer 如果有多个脚本，会按照在页面中出现的顺序加载
- 多个async 脚本不能保证加载顺序加载

