<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.67">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/vuepress_blog/images/c.png"><title>包管理器 | DaLoong的博客</title><meta name="description" content="DaLoong的博客">
    <link rel="preload" href="/vuepress_blog/assets/style-8ba6f110.css" as="style"><link rel="stylesheet" href="/vuepress_blog/assets/style-8ba6f110.css">
    <link rel="modulepreload" href="/vuepress_blog/assets/app-168a97af.js"><link rel="modulepreload" href="/vuepress_blog/assets/包管理器学习.html-8b34adc7.js"><link rel="modulepreload" href="/vuepress_blog/assets/包管理器学习.html-904b9825.js"><link rel="prefetch" href="/vuepress_blog/assets/index.html-9d13c51f.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/基于GitLab Runner的CICD部署流程.html-850cfa9e.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/index.html-778cfb5b.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/CSS3学习.html-8d464183.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/ES6学习.html-b688c695.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/HTML5学习.html-a5507529.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/HTNL_CSS基础学习.html-cb14dd7a.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/JS基础学习.html-56057ea3.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/Linux学习.html-8f42b128.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/NodeJS学习.html-67dc908c.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/Rust学习.html-4bd3189d.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/git学习.html-66129482.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/js代码开发规范.html-d79c3c14.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/mysql学习.html-796ff3ec.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/react学习.html-f8704c2c.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/vue2学习.html-9f615d29.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/webpack学习.html-91851a74.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/模块化学习.html-bf244a88.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/算法学习.html-6b287957.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/网络学习.html-f50286be.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/404.html-f9875e7b.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/index.html-a58d64d2.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/基于GitLab Runner的CICD部署流程.html-ae014ee6.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/index.html-d78c947f.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/CSS3学习.html-f95e66a5.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/ES6学习.html-7c11af0a.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/HTML5学习.html-556590f3.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/HTNL_CSS基础学习.html-0002e336.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/JS基础学习.html-9e2840a4.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/Linux学习.html-f8464ebe.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/NodeJS学习.html-b7587d5e.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/Rust学习.html-0ecf461a.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/git学习.html-1c2183d0.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/js代码开发规范.html-28bcaee9.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/mysql学习.html-40a64e2f.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/react学习.html-7cd43d5c.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/vue2学习.html-4e4342be.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/webpack学习.html-97d627c2.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/模块化学习.html-d42f575c.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/算法学习.html-fcb50873.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/网络学习.html-b520b35d.js" as="script"><link rel="prefetch" href="/vuepress_blog/assets/404.html-69018513.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/vuepress_blog/" class=""><img class="logo" src="/vuepress_blog/images/CDaLoong-logo.png" alt="DaLoong的博客"><span class="site-name can-hide">DaLoong的博客</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a class="external-link" href="https://github.com/CDaLoong" rel="noopener noreferrer" target="_blank" aria-label="Github"><!--[--><!--]--> Github <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://juejin.cn/user/2375422091464398" rel="noopener noreferrer" target="_blank" aria-label="掘金"><!--[--><!--]--> 掘金 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-color-mode-button" title="toggle color mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a class="external-link" href="https://github.com/CDaLoong" rel="noopener noreferrer" target="_blank" aria-label="Github"><!--[--><!--]--> Github <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://juejin.cn/user/2375422091464398" rel="noopener noreferrer" target="_blank" aria-label="掘金"><!--[--><!--]--> 掘金 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><a href="/vuepress_blog/" class="sidebar-item sidebar-heading" aria-label="程序员的自我修养"><!--[--><!--]--> 程序员的自我修养 <!--[--><!--]--></a><!----></li><li><p tabindex="0" class="sidebar-item sidebar-heading active collapsible">学习笔记 <span class="down arrow"></span></p><ul style="" class="sidebar-item-children"><!--[--><li><p tabindex="0" class="sidebar-item collapsible">HTNL+CSS学习 <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/vuepress_blog/note/HTNL_CSS%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.html" class="sidebar-item" aria-label="html + css 基础"><!--[--><!--]--> html + css 基础 <!--[--><!--]--></a><!----></li><li><a href="/vuepress_blog/note/HTML5%E5%AD%A6%E4%B9%A0.html" class="sidebar-item" aria-label="HTML5"><!--[--><!--]--> HTML5 <!--[--><!--]--></a><!----></li><li><a href="/vuepress_blog/note/CSS3%E5%AD%A6%E4%B9%A0.html" class="sidebar-item" aria-label="CSS3"><!--[--><!--]--> CSS3 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">JS学习 <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/vuepress_blog/note/JS%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.html" class="sidebar-item" aria-label="JavaScript基础"><!--[--><!--]--> JavaScript基础 <!--[--><!--]--></a><!----></li><li><a href="/vuepress_blog/note/ES6%E5%AD%A6%E4%B9%A0.html" class="sidebar-item" aria-label="ES6+"><!--[--><!--]--> ES6+ <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item active collapsible">工程化学习 <span class="down arrow"></span></p><ul style="" class="sidebar-item-children"><!--[--><li><a href="/vuepress_blog/note/git%E5%AD%A6%E4%B9%A0.html" class="sidebar-item" aria-label="git操作"><!--[--><!--]--> git操作 <!--[--><!--]--></a><!----></li><li><a href="/vuepress_blog/note/%E6%A8%A1%E5%9D%97%E5%8C%96%E5%AD%A6%E4%B9%A0.html" class="sidebar-item" aria-label="模块化"><!--[--><!--]--> 模块化 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vuepress_blog/note/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0.html" class="router-link-active router-link-exact-active router-link-active sidebar-item active" aria-label="包管理器"><!--[--><!--]--> 包管理器 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/vuepress_blog/note/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0.html#包管理工具理解" class="router-link-active router-link-exact-active sidebar-item" aria-label="包管理工具理解"><!--[--><!--]--> 包管理工具理解 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/vuepress_blog/note/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0.html#背景" class="router-link-active router-link-exact-active sidebar-item" aria-label="背景"><!--[--><!--]--> 背景 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/vuepress_blog/note/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0.html#前端包管理器" class="router-link-active router-link-exact-active sidebar-item" aria-label="前端包管理器"><!--[--><!--]--> 前端包管理器 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/vuepress_blog/note/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0.html#nrm" class="router-link-active router-link-exact-active sidebar-item" aria-label="nrm"><!--[--><!--]--> nrm <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vuepress_blog/note/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0.html#npm" class="router-link-active router-link-exact-active sidebar-item" aria-label="npm"><!--[--><!--]--> npm <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vuepress_blog/note/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0.html#开源协议" class="router-link-active router-link-exact-active sidebar-item" aria-label="开源协议"><!--[--><!--]--> 开源协议 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/vuepress_blog/note/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0.html#yarn" class="router-link-active router-link-exact-active sidebar-item" aria-label="yarn"><!--[--><!--]--> yarn <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/vuepress_blog/note/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0.html#yarn-简介" class="router-link-active router-link-exact-active sidebar-item" aria-label="yarn 简介"><!--[--><!--]--> yarn 简介 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vuepress_blog/note/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0.html#yarn-的核心命令" class="router-link-active router-link-exact-active sidebar-item" aria-label="yarn 的核心命令"><!--[--><!--]--> yarn 的核心命令 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vuepress_blog/note/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0.html#yarn-的特别礼物" class="router-link-active router-link-exact-active sidebar-item" aria-label="yarn 的特别礼物"><!--[--><!--]--> yarn 的特别礼物 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/vuepress_blog/note/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0.html#cnpm" class="router-link-active router-link-exact-active sidebar-item" aria-label="cnpm"><!--[--><!--]--> cnpm <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vuepress_blog/note/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0.html#nvm" class="router-link-active router-link-exact-active sidebar-item" aria-label="nvm"><!--[--><!--]--> nvm <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/vuepress_blog/note/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0.html#下载和安装" class="router-link-active router-link-exact-active sidebar-item" aria-label="下载和安装"><!--[--><!--]--> 下载和安装 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vuepress_blog/note/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0.html#使用nvm" class="router-link-active router-link-exact-active sidebar-item" aria-label="使用nvm"><!--[--><!--]--> 使用nvm <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/vuepress_blog/note/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0.html#volta" class="router-link-active router-link-exact-active sidebar-item" aria-label="volta"><!--[--><!--]--> volta <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/vuepress_blog/note/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0.html#下载和安装-1" class="router-link-active router-link-exact-active sidebar-item" aria-label="下载和安装"><!--[--><!--]--> 下载和安装 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vuepress_blog/note/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0.html#使用volta" class="router-link-active router-link-exact-active sidebar-item" aria-label="使用volta"><!--[--><!--]--> 使用volta <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/vuepress_blog/note/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0.html#pnpm" class="router-link-active router-link-exact-active sidebar-item" aria-label="pnpm"><!--[--><!--]--> pnpm <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/vuepress_blog/note/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0.html#安装和使用" class="router-link-active router-link-exact-active sidebar-item" aria-label="安装和使用"><!--[--><!--]--> 安装和使用 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vuepress_blog/note/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0.html#pnpm原理" class="router-link-active router-link-exact-active sidebar-item" aria-label="pnpm原理"><!--[--><!--]--> pnpm原理 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vuepress_blog/note/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0.html#注意事项" class="router-link-active router-link-exact-active sidebar-item" aria-label="注意事项"><!--[--><!--]--> 注意事项 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vuepress_blog/note/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0.html#概念" class="router-link-active router-link-exact-active sidebar-item" aria-label="概念"><!--[--><!--]--> 概念 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vuepress_blog/note/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E5%AD%A6%E4%B9%A0.html#pnpm原理-1" class="router-link-active router-link-exact-active sidebar-item" aria-label="pnpm原理"><!--[--><!--]--> pnpm原理 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><a href="/vuepress_blog/note/webpack%E5%AD%A6%E4%B9%A0.html" class="sidebar-item" aria-label="Webpack"><!--[--><!--]--> Webpack <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">前端框架学习 <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/vuepress_blog/note/vue2%E5%AD%A6%E4%B9%A0.html" class="sidebar-item" aria-label="前期准备"><!--[--><!--]--> 前期准备 <!--[--><!--]--></a><!----></li><li><a href="/vuepress_blog/note/react%E5%AD%A6%E4%B9%A0.html" class="sidebar-item" aria-label="React"><!--[--><!--]--> React <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">计算机基础知识学习 <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/vuepress_blog/note/%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0.html" class="sidebar-item" aria-label="网络"><!--[--><!--]--> 网络 <!--[--><!--]--></a><!----></li><li><a href="/vuepress_blog/note/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0.html" class="sidebar-item" aria-label="算法"><!--[--><!--]--> 算法 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">全栈能力学习 <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/vuepress_blog/note/NodeJS%E5%AD%A6%E4%B9%A0.html" class="sidebar-item" aria-label="Node"><!--[--><!--]--> Node <!--[--><!--]--></a><!----></li><li><a href="/vuepress_blog/note/mysql%E5%AD%A6%E4%B9%A0.html" class="sidebar-item" aria-label="MySQL数据库"><!--[--><!--]--> MySQL数据库 <!--[--><!--]--></a><!----></li><li><a href="/vuepress_blog/note/Linux%E5%AD%A6%E4%B9%A0.html" class="sidebar-item" aria-label="Linux"><!--[--><!--]--> Linux <!--[--><!--]--></a><!----></li><li><a href="/vuepress_blog/note/Rust%E5%AD%A6%E4%B9%A0.html" class="sidebar-item" aria-label="这就是Rust"><!--[--><!--]--> 这就是Rust <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">代码风格 <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><p tabindex="0" class="sidebar-item collapsible">代码开发规范 <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/vuepress_blog/note/js%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83.html" class="sidebar-item" aria-label="js代码规范"><!--[--><!--]--> js代码规范 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">实战记录 <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><p tabindex="0" class="sidebar-item collapsible">代码自动化流水线部署 <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/vuepress_blog/blog/%E5%9F%BA%E4%BA%8EGitLab%20Runner%E7%9A%84CICD%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B.html" class="sidebar-item" aria-label="基于GitLab Runner的CICD部署流程"><!--[--><!--]--> 基于GitLab Runner的CICD部署流程 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><h1 id="包管理器" tabindex="-1"><a class="header-anchor" href="#包管理器" aria-hidden="true">#</a> 包管理器</h1><h2 id="包管理工具理解" tabindex="-1"><a class="header-anchor" href="#包管理工具理解" aria-hidden="true">#</a> 包管理工具理解</h2><ul><li><strong>模块（module）</strong><ul><li>通常以单个文件形式存在的功能片段，入口文件通常称之为<strong>入口模块</strong>或<strong>主模块</strong></li></ul></li><li><strong>库（library，简称lib）</strong><ul><li>以一个或多个模块组成的完整功能块，为开发中某一方面的问题提供完整的解决方案</li></ul></li><li><strong>包（package）</strong><ul><li>包含元数据的库，这些元数据包括：名称、描述、git主页、许可证协议、作者、依赖等等</li></ul></li></ul><p><img src="/vuepress_blog/assets/1-a39009a9.png" alt="image.png"></p><h3 id="背景" tabindex="-1"><a class="header-anchor" href="#背景" aria-hidden="true">#</a> 背景</h3><ul><li>CommonJS 的出现，使 node 环境下的 JS 代码可以用模块更加细粒度的划分。一个类、一个函数、一个对象、一个配置等等均可以作为模块，这种细粒度的划分，是开发大型应用的基石。</li><li>为了解决在开发过程中遇到的常见问题，比如加密、提供常见的工具方法、模拟数据等等，一时间，在前端社区涌现了大量的第三方库。这些库使用 CommonJS 标准书写而成，非常容易使用。</li><li>然而，在下载使用这些第三方库的时候，遇到难以处理的问题： <ul><li><strong>下载过程繁琐</strong><ul><li>进入官网或 github 主页</li><li>找到并下载相应的版本</li><li>拷贝到工程的目录中</li><li>如果遇到有同名的库，需要更改名称</li></ul></li><li><strong>如果该库需要依赖其他库，还需要按照要求先下载其他库</strong></li><li><strong>开发环境中安装的大量的库如何在生产环境中还原，又如何区分</strong></li><li><strong>更新一个库极度麻烦</strong></li><li><strong>自己开发的库，如何在下一次开发使用</strong></li></ul></li><li><strong>以上问题，就是包管理工具要解决的问题</strong></li></ul><h2 id="前端包管理器" tabindex="-1"><a class="header-anchor" href="#前端包管理器" aria-hidden="true">#</a> 前端包管理器</h2><blockquote><p>npm：重点 yarn：次重点 其他：了解</p></blockquote><ul><li>几乎可以这样认为，前端所有的包管理器都是基于 npm 的，目前，npm 即是一个包管理器，也是其他包管理的基石</li><li>npm 全称为 node package manager，即 node 包管理器，它运行在 node 环境中，让开发者可以用简单的方式完成包的查找、安装、更新、卸载、上传等操作</li></ul><blockquote><p>npm 之所以要运行在 node 环境，而不是浏览器环境，根本原因是因为浏览器环境无法提供下载、删除、读取本地文件的功能。而 node 属于服务器环境，没有浏览器的种种限制，理论上可以完全掌控运行 node 的计算机。</p></blockquote><ul><li>npm 的出现，弥补了 node 没有包管理器的缺陷，于是很快，node 在安装文件中内置了 npm，当开发者安装好 node 之后，就自动安装了 npm，不仅如此，node 环境还专门为 npm 提供了良好的支持，使用 npm 下载的包更加方便了。</li><li>npm 由三部分组成： <ul><li>registry：入口 <ul><li>可以把它想象成一个庞大的数据库</li><li>第三方库的开发者，将自己的库按照 npm 的规范，打包上传到数据库中</li><li>使用者通过统一的地址下载第三方包</li></ul></li><li>官网：<a href="https://www.npmjs.com/" target="_blank" rel="noopener noreferrer">https://www.npmjs.com/<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a><ul><li>查询包</li><li>注册、登录、管理个人信息</li></ul></li><li>CLI：command-line interface 命令行接口 <ul><li>安装好 npm 后，通过 CLI 来使用 npm 的各种功能</li></ul></li></ul></li></ul><blockquote><p>node 和 npm 是互相成就的，node 的出现让 npm 火了，npm 的火爆带动了大量的第三方库的发展，很多优秀的第三方库打包上传到了 npm，这些第三方库又为 node 带来了大量的用户</p></blockquote><h3 id="nrm" tabindex="-1"><a class="header-anchor" href="#nrm" aria-hidden="true">#</a> nrm</h3><p><code>npm install nrm -g</code> 使用 nrm 管理包管理器</p><h3 id="npm" tabindex="-1"><a class="header-anchor" href="#npm" aria-hidden="true">#</a> npm</h3><h4 id="包的安装" tabindex="-1"><a class="header-anchor" href="#包的安装" aria-hidden="true">#</a> 包的安装</h4><ul><li>安装（install），即下载包 由于 npm 的官方 registry 服务器位于国外，可能受网速影响导致下载缓慢或失败。因此，安装好 npm 之后，需要重新设置 registry 的地址为国内地址 <ul><li>目前，淘宝 <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener noreferrer">https://registry.npm.taobao.org<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 提供了国内的 registry 地址，先设置到该地址</li><li>设置方式为<code>npm config set registry https://registry.npm.taobao.or</code></li><li>设置好后，通过命令<code>npm config get registry</code>进行检查</li></ul></li></ul><p><img src="/vuepress_blog/assets/2-cf0c8394.png" alt="image.png"> npm 安装一个包，分为两种安装方式：</p><ol><li>本地安装</li><li>全局安装</li></ol><h5 id="本地安装" tabindex="-1"><a class="header-anchor" href="#本地安装" aria-hidden="true">#</a> 本地安装</h5><ul><li>使用命令<code>npm install 包名</code>或<code>npm i 包名</code>即可完成本地安装</li><li>本地安装的包出现在当前目录下的<code>node_modules</code>目录中 <ul><li>随着开发的进展，<code>node_modules</code>目录会变得异常庞大，目录下的内容不适合直接传输到生产环境，因此通常使用<code>.gitignore</code>文件忽略该目录中的内容</li><li>本地安装适用于绝大部分的包，它会在当前目录及其子目录中发挥作用</li><li>通常在项目的根目录中使用本地安装</li><li>安装一个包的时候，npm 会自动管理依赖，它会下载该包的依赖包到<code>node_modules</code>目录中</li><li>如果本地安装的包带有 CLI，npm 会将它的 CLI 脚本文件放置到<code>node_modules/.bin</code>下，使用命令<code>npx 命令名</code>即可调用</li></ul></li></ul><h5 id="全局安装" tabindex="-1"><a class="header-anchor" href="#全局安装" aria-hidden="true">#</a> 全局安装</h5><ul><li>全局安装的包放置在一个特殊的全局目录，该目录可以通过命令<code>npm config get prefix</code>查看</li><li>使用命令<code>npm install --global 包名</code> 或 <code>npm i -g 包名</code></li><li>重要：<strong>全局安装的包并非所有工程可用，它仅提供全局的 CLI 工具</strong></li><li>大部分情况下，都不需要全局安装包，除非： <ul><li>包的版本非常稳定，很少有大的更新</li><li>提供的 CLI 工具在各个工程中使用的非常频繁</li><li>CLI 工具仅为开发环境提供支持，而非部署环境</li></ul></li></ul><h4 id="包配置" tabindex="-1"><a class="header-anchor" href="#包配置" aria-hidden="true">#</a> 包配置</h4><ul><li>目前遇到的问题： <ul><li>拷贝工程后如何还原？</li><li>如何区分开发依赖和生产依赖？</li><li>如果自身的项目也是一个包，如何描述包的信息</li></ul></li><li>以上这些问题都需要通过包的<strong>配置文件</strong>解决</li></ul><h5 id="配置文件" tabindex="-1"><a class="header-anchor" href="#配置文件" aria-hidden="true">#</a> 配置文件</h5><ul><li>npm 将每个使用 npm 的工程本身都看作是一个包，包的信息需要通过一个名称固定的配置文件来描述</li><li><strong>配置文件的名称固定为：package.json</strong></li><li>可以手动创建该文件，而更多的时候，是通过命令<code>npm init</code>创建的</li><li>配置文件中可以描述大量的信息，包括： <ul><li>name：包的名称，该名称必须是<strong>英文单词字符</strong>，支持连接符</li><li>version：版本 <ul><li>版本规范：主版本号.次版本号.补丁版本号 <ul><li>主版本号：仅当程序发生了重大变化时才会增长，如新增了重要功能、新增了大量的API、技术架构发生了重大变化</li><li>次版本号：仅当程序发生了一些小变化时才会增长，如新增了一些小功能、新增了一些辅助型的API</li><li>补丁版本号：仅当解决了一些 bug 或 进行了一些局部优化时更新，如修复了某个函数的 bug、提升了某个函数的运行效率</li></ul></li></ul></li><li>description：包的描述</li><li>homepage：官网地址</li><li>author：包的作者，必须是有效的 npm 账户名，书写规范是 <code>account &lt;mail&gt;</code><ul><li>例如：<code>zhangsan &lt;zhangsan@gmail.com&gt;</code>，不正确的账号和邮箱可能导致发布包时失败</li></ul></li><li>repository：包的仓储地址，通常指 git 或 svn 的地址，它是一个对象 <ul><li>type：仓储类型，git 或 svn</li><li>url：地址</li></ul></li><li>main：包的入口文件，使用包的人默认从该入口文件导入包的内容</li><li>keywords: 搜索关键字，发布包后，可以通过该数组中的关键字搜索到包</li></ul></li><li>使用<code>npm init --yes</code>或<code>npm init -y</code>可以在生成配置文件时自动填充默认配置</li></ul><h4 id="保存依赖关系" tabindex="-1"><a class="header-anchor" href="#保存依赖关系" aria-hidden="true">#</a> 保存依赖关系</h4><ul><li>大部分时候，我们仅仅是开发项目，并不会把它打包发布出去，尽管如此，我们仍然需要package.json文件</li><li><strong>package.json文件最重要的作用，是记录当前工程的依赖</strong><ul><li>dependencies：生产环境的依赖包</li><li>devDependencies：仅开发环境的依赖包</li></ul></li><li>配置好依赖后，使用下面的命令即可安装依赖</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment">## 本地安装所有依赖 dependencies + devDependencies</span>
<span class="token function">npm</span> <span class="token function">install</span>
<span class="token function">npm</span> i

<span class="token comment">## 仅安装生产环境的依赖 dependencies</span>
<span class="token function">npm</span> <span class="token function">install</span> <span class="token parameter variable">--production</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>这样一来，代码移植就不是问题了，只需要移植源代码和package.json文件，不用移植node_modules目录，然后在移植之后通过命令即可重新恢复安装</li><li>为了更加方便的添加依赖，npm支持在使用install命令时，加入一些额外的参数，用于将安装的依赖包保存到package.json文件中</li><li>涉及的命令如下</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment">## 安装依赖到生产环境</span>
<span class="token function">npm</span> i 包名
<span class="token function">npm</span> i <span class="token parameter variable">--save</span> 包名
<span class="token function">npm</span> i <span class="token parameter variable">-S</span> 包名

<span class="token comment">## 安装依赖到开发环境</span>
<span class="token function">npm</span> i --save-dev 包名
<span class="token function">npm</span> i <span class="token parameter variable">-D</span> 包名
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>自动保存的依赖版本，例如<code>^15.1.3</code>，这种书写方式叫做语义版本号（semver version）</p></blockquote><h4 id="包的使用" tabindex="-1"><a class="header-anchor" href="#包的使用" aria-hidden="true">#</a> 包的使用</h4><ul><li>nodejs 对 npm 支持非常良好</li><li>当使用 nodejs 导入模块时，如果模块路径不是以 ./ 或 ../ 开头，则 node 会认为导入的模块来自于 node_modules 目录，例如：</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> _ <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;lodash&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>它首先会从当前目录的以下位置寻找文件</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>node_modules/lodash.js
node_modules/lodash/入口文件
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>若当前目录没有这样的文件，则会回溯到上级目录按照同样的方式查找</li><li>如果到顶级目录都无法找到文件，则抛出错误</li><li>上面提到的入口文件按照以下规则确定 <ul><li>查看导入包的package.json文件，读取main字段作为入口文件</li><li>若不包含main字段，则使用index.js作为入口文件</li></ul></li></ul><blockquote><p>入口文件的规则同样适用于自己工程中的模块 在 node 中，还可以手动指定路径来导入相应的文件，这种情况比较少见</p></blockquote><h4 id="语义版本" tabindex="-1"><a class="header-anchor" href="#语义版本" aria-hidden="true">#</a> 语义版本</h4><p>思考：如果你编写了一个包A，依赖另外一个包B，你在编写代码时，包B的版本是2.4.1，你是希望使用你包的人一定要安装包B，并且是2.4.1版本，还是希望他可以安装更高的版本，如果你希望它安装更高的版本，高的什么程度呢？</p><ul><li>回顾：版本号规则</li><li>版本规范：主版本号.次版本号.补丁版本号 <ul><li>主版本号：仅当程序发生了重大变化时才会增长，如新增了重要功能、新增了大量的API、技术架构发生了重大变化</li><li>次版本号：仅当程序发生了一些小变化时才会增长，如新增了一些小功能、新增了一些辅助型的API</li><li>补丁版本号：仅当解决了一些 bug 或 进行了一些局部优化时更新，如修复了某个函数的 bug、提升了某个函数的运行效率</li></ul></li><li>有的时候，我们希望：安装我的依赖包的时候，次版本号和补丁版本号是可以有提升的，但是主版本号不能变化</li><li>有的时候，我们又希望：安装我的依赖包的时候，只有补丁版本号可以提升，其他都不能提升</li><li>甚至我们希望依赖包保持固定的版本，尽管这比较少见</li><li>这样一来，就需要在配置文件中描述清楚具体的依赖规则，而不是直接写上版本号那么简单。</li><li>这种规则的描述，即<strong>语义版本</strong></li><li>语义版本的书写规则非常丰富，下面列出了一些常见的书写方式 | 符号 | 描述 | 示例 | 示例描述 | | --- | --- | --- | --- | | &gt; | 大于某个版本 | &gt;1.2.1 | 大于1.2.1版本 | | &gt;= | 大于等于某个版本 | &gt;=1.2.1 | 大于等于1.2.1版本 | | &lt; | 小于某个版本 | &lt;1.2.1 | 小于1.2.1版本 | | &lt;= | 小于等于某个版本 | &lt;=1.2.1 | 小于等于1.2.1版本 | | - | 介于两个版本之间 | 1.2.1 - 1.4.5 | 介于1.2.1和1.4.5之间 | | x | 不固定的版本号 | 1.3.x | 只要保证主版本号是1，次版本号是3即可 | | ~ | 补丁版本号可增 | ~1.3.4 | 保证主版本号是1，次版本号是3，补丁版本号大于等于4 | | ^ | 此版本和补丁版本可增 | ^1.3.4 | 保证主版本号是1，次版本号可以大于等于3，补丁版本号可以大于等于4 | | * | 最新版本 | * | 始终安装最新版本 |</li></ul><h4 id="避免还原的差异" tabindex="-1"><a class="header-anchor" href="#避免还原的差异" aria-hidden="true">#</a> 避免还原的差异</h4><ul><li>版本依赖控制始终是一个两难的问题</li><li>如果允许版本增加，可以让依赖包的bug得以修复（补丁版本号），可以带来一些意外的惊喜（次版本号），但同样可能带来不确定的风险（新的bug）</li><li>如果不允许版本增加，可以获得最好的稳定性，但失去了依赖包自我优化的能力</li><li>而有的时候情况更加复杂，如果依赖包升级后，依赖也发生了变化，会有更多不确定的情况出现</li><li>基于此，npm 在安装包的时候，会自动生成一个 package-lock.json 文件，该文件记录了安装包时的确切依赖关系</li><li>当移植工程时，如果移植了 package-lock.json 文件，恢复安装时，会按照 package-lock.json 文件中的确切依赖进行安装，最大限度的避免了差异</li></ul><h4 id="npm的差异版本处理" tabindex="-1"><a class="header-anchor" href="#npm的差异版本处理" aria-hidden="true">#</a> npm的差异版本处理</h4><p>如果两个包依赖同一个包的不同版本，如下图 <img src="/vuepress_blog/assets/3-38b36f5c.png" alt="image.png"> 面对这种情况，在 node_modules 目录中，不会使用扁平的目录结构，而会形成嵌套的目录，如下图：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>├── node_modules
│   ├── a 
│   │   ├── node_modules
│   │   │   ├── c
│   │   │   |   |—— c包的文件
│   │   │── a包的文件     
│   ├── b 
│   │   ├── node_modules
│   │   │   ├── c
│   │   │   |   |—— c包的文件
│   │   │── b包的文件
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="npm-脚本-npm-scripts" tabindex="-1"><a class="header-anchor" href="#npm-脚本-npm-scripts" aria-hidden="true">#</a> npm 脚本 （npm scripts）</h4><ul><li>在开发的过程中，我们可能会反复使用很多的 CLI 命令，例如： <ul><li>启动工程命令（node 或 一些第三方包提供的CLI命令）</li><li>部署工程命令（一些第三方包提供的CLI命令）</li><li>测试工程命令（一些第三方包提供的CLI命令）</li></ul></li><li>这些命令纷繁复杂，根据第三方包的不同命令也会不一样，非常难以记忆</li><li>于是，npm 非常贴心的支持了脚本，只需要在 package.json 中配置 scripts 字段，即可配置各种脚本名称</li><li>之后，我们就可以运行简单的指令来完成各种操作了</li><li>运行方式是 <code>npm run 脚本名称</code></li><li>不仅如此，npm 还对某些常用的脚本名称进行了简化，下面的脚本名称是不需要使用run的： <ul><li>start</li><li>stop</li><li>test</li></ul></li></ul><p>一些细节：</p><ul><li>脚本中可以省略npm</li><li>start脚本有默认值：node server.js</li></ul><h4 id="npx" tabindex="-1"><a class="header-anchor" href="#npx" aria-hidden="true">#</a> npx</h4><p>npx是一个工具，npm v5.2.0引入的一条命令（npx），一个npm包执行器，指在提高从npm注册表使用软件包时的体验 ，npm使得它非常容易地安装和管理托管在注册表上的依赖项，npx使得使用CLI工具和其他托管在注册表。 所以现在大部分的开发者都可以直接使用到 npx 的功能。 npx 仍然是一个简单的 cli 工具，来让我们更加方便的执行一些 npm 包，而不用通过 npm 来将包安装到开发者的电脑上面。 主要特点： 1、临时安装可执行依赖包，不用全局安装，不用担心长期的污染。 2、可以执行依赖包中的命令，安装完成自动运行。 3、自动加载node_modules中依赖包，不用指定$PATH。 4、可以指定node版本、命令的版本，解决了不同项目使用不同版本的命令的问题。 npx 为 npm 文件执行功能进行了一些扩展，提供了一种使用 node.js CLI 工具的新方式，这种方式比起以前的执行方式更加灵活，并且对于本地环境变量的污染更小（你可以到自己的 node 安装目录下看一下，有多少个 bin 目录下的软连接在污染你的环境变量）。指定包版本的功能可以让我们更灵活地测试一些新的功能，而不用进行升级和降级，还是能够带来很多方便的。</p><h4 id="运行环境配置" tabindex="-1"><a class="header-anchor" href="#运行环境配置" aria-hidden="true">#</a> 运行环境配置</h4><p>我们书写的代码一般有三种运行环境：</p><ol><li>开发环境</li><li>生产环境</li><li>测试环境</li></ol><ul><li>有的时候，我们可能需要在 node 代码中根据不同的环境做出不同的处理</li><li>如何优雅的让 node 知道处于什么环境，是极其重要的</li><li>通常我们使用如下的处理方式： <ul><li>node中有一个全局变量 global (可以类比浏览器环境的window)，该变量是一个对象，对象中的所有属性均可以直接使用</li><li>global有一个属性是process，该属性是一个对象，包含了当前运行node程序的计算机的很多信息，其中有一个信息是env，是一个对象，包含了计算机中所有的系统变量 <ul><li>通常，我们通过系统变量 NODE_ENV 的值，来判定node程序处于何种环境</li><li>有两种方式设置 NODE_ENV 的值 <ol><li>永久设置</li><li>临时设置</li></ol><ul><li>我们一般使用临时设置</li><li>因此，我们可以配置 scripts 脚本，在设置好了 NODE_ENV 后启动程序</li></ul></li></ul></li></ul></li></ul><blockquote><p>为了避免不同系统的设置方式的差异，可以使用第三方库 cross-env 对环境变量进行设置</p></blockquote><h4 id="在node中读取package-json" tabindex="-1"><a class="header-anchor" href="#在node中读取package-json" aria-hidden="true">#</a> 在node中读取package.json</h4><ul><li>有的时候，我们可能在 package.json 中配置一些自定义的字段，这些字段需要在node中读取</li><li>在node 中，可以直接导入一个json格式的文件，它会自动将其转换为js对象</li></ul><h4 id="其他npm命令" tabindex="-1"><a class="header-anchor" href="#其他npm命令" aria-hidden="true">#</a> 其他npm命令</h4><ul><li>npm install -d 就是 npm install --save-dev 安装到开发环境 例如 gulp ，babel，webpack 一般都是辅助工具</li><li>npm install -s 就是npm install --save 安装到生产环境 如 vue ,react 等</li></ul><h5 id="安装" tabindex="-1"><a class="header-anchor" href="#安装" aria-hidden="true">#</a> 安装</h5><ul><li>精确安装最新版本</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">npm</span> <span class="token function">install</span> --save-exact 包名 
<span class="token function">npm</span> <span class="token function">install</span> <span class="token parameter variable">-E</span> 包名
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>安装指定版本</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">npm</span> <span class="token function">install</span> 包名@版本号
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h5 id="查询" tabindex="-1"><a class="header-anchor" href="#查询" aria-hidden="true">#</a> 查询</h5><ul><li>查询包安装路径</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">npm</span> root <span class="token punctuation">[</span>-g<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>查看包信息</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">npm</span> view 包名 <span class="token punctuation">[</span>子信息<span class="token punctuation">]</span>
<span class="token comment">## view aliases：v info show</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>查询安装包</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">npm</span> list <span class="token punctuation">[</span>-g<span class="token punctuation">]</span> <span class="token punctuation">[</span>--depth<span class="token operator">=</span>依赖深度<span class="token punctuation">]</span>
<span class="token comment">## list aliases: ls  la  ll</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="更新" tabindex="-1"><a class="header-anchor" href="#更新" aria-hidden="true">#</a> 更新</h5><ul><li>检查有哪些包需要更新</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">npm</span> outdated
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>更新包</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">npm</span> update <span class="token punctuation">[</span>-g<span class="token punctuation">]</span> <span class="token punctuation">[</span>包名<span class="token punctuation">]</span>
<span class="token comment">## update 别名（aliases）：up、upgrade</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="卸载包" tabindex="-1"><a class="header-anchor" href="#卸载包" aria-hidden="true">#</a> 卸载包</h5><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">npm</span> uninstall <span class="token punctuation">[</span>-g<span class="token punctuation">]</span> 包名
<span class="token comment">## uninstall aliases: remove, rm, r, un, unlink</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="npm-配置" tabindex="-1"><a class="header-anchor" href="#npm-配置" aria-hidden="true">#</a> npm 配置</h4><ul><li>npm的配置会对其他命令产生或多或少的影响</li><li>安装好npm之后，最终会产生两个配置文件，一个是用户配置，一个是系统配置，当两个文件的配置项有冲突的时候，用户配置会覆盖系统配置</li><li>通常，我们不关心具体的配置文件，而只关心最终生效的配置</li><li>通过下面的命令可以查询目前生效的各种配置</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">npm</span> config <span class="token function">ls</span> <span class="token punctuation">[</span>-l<span class="token punctuation">]</span> <span class="token punctuation">[</span>--json<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>另外，可以通过下面的命令操作配置 <ul><li>获取某个配置项</li></ul></li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">npm</span> config get 配置项
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>设置某个配置项</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">npm</span> config <span class="token builtin class-name">set</span> 配置项<span class="token operator">=</span>值
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>移除某个配置项</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">npm</span> config delete 配置项
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="发布包" tabindex="-1"><a class="header-anchor" href="#发布包" aria-hidden="true">#</a> 发布包</h4><h5 id="准备工作" tabindex="-1"><a class="header-anchor" href="#准备工作" aria-hidden="true">#</a> 准备工作</h5><ul><li>移除淘宝镜像源</li><li>到npm官网注册一个账号，并完成邮箱认证</li><li>本地使用 npm cli 进行登录 <ul><li>使用命令<code>npm login</code>登录</li><li>使用命令<code>npm whoami</code>查看当前登录的账号</li><li>使用命令<code>npm logout</code>注销</li></ul></li><li>创建工程根目录</li><li>使用npm init进行初始化</li></ul><h5 id="发布" tabindex="-1"><a class="header-anchor" href="#发布" aria-hidden="true">#</a> 发布</h5><ul><li>开发</li><li>确定版本</li><li>使用命令<code>npm publish</code>完成发布</li></ul><h3 id="开源协议" tabindex="-1"><a class="header-anchor" href="#开源协议" aria-hidden="true">#</a> 开源协议</h3><p><img src="/vuepress_blog/assets/4-458b2710.png" alt="image.png"> 可以通过网站 <a href="http://choosealicense.online/appendix/" target="_blank" rel="noopener noreferrer">http://choosealicense.online/appendix/<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 选择协议，并复制协议内容</p><h2 id="yarn" tabindex="-1"><a class="header-anchor" href="#yarn" aria-hidden="true">#</a> yarn</h2><h3 id="yarn-简介" tabindex="-1"><a class="header-anchor" href="#yarn-简介" aria-hidden="true">#</a> yarn 简介</h3><blockquote><p>yarn 官网：<a href="https://www.yarnpkg.com/zh-Hans/" target="_blank" rel="noopener noreferrer">https://www.yarnpkg.com/zh-Hans/<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></blockquote><ul><li>yarn 是由Facebook、Google、Exponent 和 Tilde 联合推出了一个新的 JS 包管理工具，<strong>它仍然使用 npm 的registry</strong>，不过提供了全新 CLI 来对包进行管理</li><li>过去，yarn 的出现极大的抢夺了 npm 的市场，甚至有人戏言，npm 只剩下一个 registry 了。</li><li>之所以会出现这种情况，是因为在过去，npm 存在下面的问题： <ul><li>依赖目录嵌套层次深：过去，npm 的依赖是嵌套的，这在 windows 系统上是一个极大的问题，由于众所周知的原因，windows 系统无法支持太深的目录</li><li>下载速度慢 <ul><li>由于嵌套层次的问题，所以npm对包的下载只能是串行的，即前一个包下载完后才会下载下一个包，导致带宽资源没有完全利用</li><li>多个相同版本的包被重复的下载</li></ul></li><li>控制台输出繁杂：过去，npm 安装包的时候，每安装一个依赖，就会输出依赖的详细信息，导致一次安装有大量的信息输出到控制台，遇到错误极难查看</li><li>工程移植问题：由于 npm 的版本依赖可以是模糊的，可能会导致工程移植后，依赖的确切版本不一致</li></ul></li><li>针对上述问题，yarn 从诞生那天就已经解决，它用到了以下的手段： <ul><li>使用扁平的目录结构</li><li>并行下载</li><li>使用本地缓存</li><li>控制台仅输出关键信息</li><li>使用yanr-lock文件记录确切依赖</li></ul></li><li>不仅如此，yarn还优化了以下内容： <ul><li>增加了某些功能强大的命令</li><li>让既有的命令更加语义化</li><li>本地安装的CLI工具可以使用 yarn 直接启动</li><li>将全局安装的目录当作一个普通的工程，生成package.json文件，便于全局安装移植</li></ul></li><li>yarn 的出现给 npm 带来了巨大的压力，很快，npm 学习了 yarn 先进的理念，不断的对自身进行优化，到了目前的npm6版本，几乎完全解决了上面的问题： <ul><li>目录扁平化</li><li>并行下载</li><li>本地缓存</li><li>使用package-lock记录确切依赖</li><li>增加了大量的命令别名</li><li>内置了npx，可以启动本地的CLI工具</li><li>极大的简化了控制台输出</li></ul></li></ul><p><strong>总结</strong></p><ul><li>npm6 之后，可以说npm已经和yarn非常接近，甚至没有差距了。很多新的项目，又重新从yarn转回到npm</li><li>这两个包管理器是目前的主流，都必须要学习</li></ul><h3 id="yarn-的核心命令" tabindex="-1"><a class="header-anchor" href="#yarn-的核心命令" aria-hidden="true">#</a> yarn 的核心命令</h3><ul><li><strong>初始化</strong><ul><li>初始化：<code>yarn init [--yes/-y]</code></li></ul></li><li><strong>安装</strong><ul><li>添加指定包：<code>yarn [global] add package-name [--dev/-D] [--exact/-E]</code>，加global是全局安装</li><li>安装package.json中的所有依赖：<code>yarn install [--production/--prod]</code></li></ul></li><li><strong>脚本和本地CLI</strong><ul><li>运行脚本：<code>yarn run 脚本名</code><ul><li>start、stop、test可以省略run</li></ul></li><li>运行本地安装的CLI：<code>yarn run CLI名</code></li></ul></li><li><strong>查询</strong><ul><li>查看bin目录：<code>yarn [global] bin</code></li><li>查询包信息：<code>yarn info 包名 [子字段]</code></li><li>列举已安装的依赖：<code>yarn [global] list [--depth=依赖深度]</code><ul><li>yarn的list命令和npm的list不同，yarn输出的信息更加丰富，包括顶级目录结构、每个包的依赖版本号</li></ul></li></ul></li><li><strong>更新</strong><ul><li>列举需要更新的包：<code>yarn outdated</code></li><li>更新包：<code>yarn [global] upgrade [包名]</code></li></ul></li><li><strong>卸载</strong><ul><li>卸载包：<code>yarn remove 包名</code></li></ul></li></ul><h3 id="yarn-的特别礼物" tabindex="-1"><a class="header-anchor" href="#yarn-的特别礼物" aria-hidden="true">#</a> yarn 的特别礼物</h3><p>在终端命令上，yarn不仅仅是对npm的命令做了一个改名，还增加了一些原本没有的命令，这些命令在某些时候使用起来非常方便</p><ul><li><strong>yarn check</strong><ul><li>使用<code>yarn check</code>命令，可以验证package.json文件的依赖记录和lock文件是否一致</li><li>这对于防止篡改非常有用</li></ul></li><li><strong>yarn audit</strong><ul><li>使用<code>yarn audit</code>命令，可以检查本地安装的包有哪些已知漏洞，以表格的形式列出，漏洞级别分为以下几种： <ul><li>INFO：信息级别</li><li>LOW: 低级别</li><li>MODERATE：中级别</li><li>HIGH：高级别</li><li>CRITICAL：关键级别</li></ul></li></ul></li><li><strong>yarn why</strong><ul><li>使用<code>yarn why 包名</code>命令，可以在控制台打印出为什么安装了这个包，哪些包会用到它</li></ul></li><li><strong>yarn create</strong><ul><li>非常有趣的命令</li><li>今后，我们会学习一些脚手架，所谓脚手架，就是使用一个命令来搭建一个工程结构</li><li>过去，我们都是使用如下的做法： <ul><li>全局安装脚手架工具</li><li>使用全局命令搭建脚手架</li></ul></li><li>由于大部分脚手架工具都是以<code>create-xxx</code>的方式命名的，比如react的官方脚手架名称为<code>create-react-app</code></li><li>因此，可以使用<code>yarn create</code>命令来一步完成安装和搭建</li></ul></li></ul><p>例如：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">yarn</span> create react-app my-app
<span class="token comment"># 等同于下面的两条命令</span>
<span class="token function">yarn</span> global <span class="token function">add</span> create-react-app
create-react-app my-app
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="cnpm" tabindex="-1"><a class="header-anchor" href="#cnpm" aria-hidden="true">#</a> cnpm</h2><blockquote><p>官网地址：<a href="https://npm.taobao.org/" target="_blank" rel="noopener noreferrer">https://npm.taobao.org/<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></blockquote><ul><li>为解决国内用户连接npm registry缓慢的问题，淘宝搭建了自己的registry，即淘宝npm镜像源</li><li>过去，npm没有提供修改registry的功能，因此，淘宝提供了一个CLI工具即cnpm，它支持除了<code>npm publish</code>以外的所有命令，只不过连接的是淘宝镜像源</li><li>如今，npm已经支持修改registry了，可能cnpm唯一的作用就是和npm共存，即如果要使用官方源，则使用npm，如果使用淘宝源，则使用cnpm</li></ul><h2 id="nvm" tabindex="-1"><a class="header-anchor" href="#nvm" aria-hidden="true">#</a> nvm</h2><ul><li>nvm并非包管理器，它是用于管理多个node版本的工具</li><li>在实际的开发中，可能会出现多个项目分别使用的是不同的node版本，在这种场景下，管理不同的node版本就显得尤为重要</li><li>nvm就是用于切换版本的一个工具</li></ul><h3 id="下载和安装" tabindex="-1"><a class="header-anchor" href="#下载和安装" aria-hidden="true">#</a> 下载和安装</h3><p>最新版下载地址：<a href="https://github.com/coreybutler/nvm-windows/releases" target="_blank" rel="noopener noreferrer">https://github.com/coreybutler/nvm-windows/releases<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 下载nvm-setup.zip后，直接安装</p><h3 id="使用nvm" tabindex="-1"><a class="header-anchor" href="#使用nvm" aria-hidden="true">#</a> 使用nvm</h3><ul><li>nvm提供了CLI工具，用于管理node版本</li><li>在终端中输入nvm，以查看各种可用命令</li><li>M1 安装 node 低版本时，先执行 <code>arch -x86_64 zsh</code>，再进行 <code>nvm install</code></li><li>查看 node 所有版本 <code>nvm ls-remote</code></li><li>nvm 修改默认版本 <code>nvm alias default 16.13.1</code></li></ul><blockquote><p>为了加快下载速度，建议设置淘宝镜像 node淘宝镜像：<a href="https://npm.taobao.org/mirrors/node/" target="_blank" rel="noopener noreferrer">https://npm.taobao.org/mirrors/node/<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> npm淘宝镜像：<a href="https://npm.taobao.org/mirrors/npm/" target="_blank" rel="noopener noreferrer">https://npm.taobao.org/mirrors/npm/<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></blockquote><h2 id="volta" tabindex="-1"><a class="header-anchor" href="#volta" aria-hidden="true">#</a> volta</h2><ul><li>volta 是新一代的node版本管理工具，</li><li>它具有以下特点： <ul><li>rust编译，更安全且加载运行速度更快</li><li>多个项目无缝切换node版本或包管理器</li><li>跨平台，包括Windows和所有Unix shell(Linux\macOS)</li><li>支持node、npm、yarn、pnpm等多个包管理器</li><li>拥有可扩展性钩子，可以定制化</li></ul></li></ul><h3 id="下载和安装-1" tabindex="-1"><a class="header-anchor" href="#下载和安装-1" aria-hidden="true">#</a> 下载和安装</h3><p>官网：<a href="https://volta.sh/" target="_blank" rel="noopener noreferrer">https://volta.sh/<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><ul><li>curl https://get.volta.sh | bash</li><li>Mac M1 安装完成后需要手动配置 shell 和 path，否则使用 volta 下载 node 的时候会报错 <ul><li><code>export VOLTA_HOME=&quot;$HOME/.volta&quot;</code></li><li><code>export PATH=&quot;$VOLTA_HOME/bin:$PATH&quot;</code></li></ul></li></ul><h3 id="使用volta" tabindex="-1"><a class="header-anchor" href="#使用volta" aria-hidden="true">#</a> 使用volta</h3><ul><li>volta fetch [FLAGS] &lt;tool[@version]&gt; 将工具下载到本地缓存中，而无需将其设置为默认值或使其可用，以供将来离线使用 <ul><li>Tools to fetch, like <code>node</code>, <code>yarn@latest</code> or <code>your-package@^14.4.3</code></li></ul></li><li>volta install [FLAGS] &lt;tool[@version]&gt; 设置工具的默认版本，如果该工具尚未在本地缓存，它也会获取该工具 <ul><li>Tools to install, like <code>node</code>, <code>yarn@latest</code> or <code>your-package@^14.4.3</code></li></ul></li><li>volta uninstall [FLAGS] &lt;tool[@version]&gt; 删除已使用 volta install 安装的任何全局软件包 <ul><li>The tool to uninstall, e.g. <code>node</code>, <code>npm</code>, <code>yarn</code>, or <code>&lt;package&gt;</code></li></ul></li><li>volta pin [FLAGS] &lt;tool[@version]&gt; 更新项目的 package.json 文件以使用选定版本的工具 <ul><li>Tools to pin, like <code>node@lts</code> or <code>yarn@^1.14</code></li><li>会将版本信息记录在 package.json 的 <code>&quot;volta&quot;: {}</code> 里，再次打开控制台将读取此信息使用记录的版本，不同项目无缝丝滑切换</li></ul></li><li>volta list [FLAGS] [OPTIONS] [tool] 检查已安装的 Node 版本、包管理器和带有二进制文件的包 <ul><li>The tool to lookup: <code>all</code>, <code>node</code>, <code>yarn</code>, or the name of a package or binary</li><li>volta list all 查看所有已安装的工具</li><li>volta list node 查看所有已安装的 Node 版本</li></ul></li></ul><p>其他的用法参考官网，很详细：<a href="https://docs.volta.sh/reference/" target="_blank" rel="noopener noreferrer">https://docs.volta.sh/reference/<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h2 id="pnpm" tabindex="-1"><a class="header-anchor" href="#pnpm" aria-hidden="true">#</a> pnpm</h2><ul><li>pnpm是一种新起的包管理器，从npm的下载量看，目前还没有超过yarn，但它的实现方式值得主流包管理器学习，某些开发者极力推荐使用pnpm</li><li>从结果上来看，它具有以下优势： <ul><li>目前，安装效率高于npm和yarn的最新版</li><li>极其简洁的node_modules目录</li><li>避免了开发时使用间接依赖的问题</li><li>能极大的降低磁盘空间的占用</li></ul></li></ul><h3 id="安装和使用" tabindex="-1"><a class="header-anchor" href="#安装和使用" aria-hidden="true">#</a> 安装和使用</h3><ul><li>全局安装pnpm</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">npm</span> <span class="token function">install</span> <span class="token parameter variable">-g</span> <span class="token function">pnpm</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>之后在使用时，只需要把npm替换为pnpm即可</li><li>如果要执行安装在本地的CLI，可以使用pnpx，它和 npx 的功能完全一样，唯一不同的是，在使用pnpx执行一个需要安装的命令时，会使用pnpm进行安装</li></ul><blockquote><p>比如<code>npx mocha</code>执行本地的<code>mocha</code>命令时，如果<code>mocha</code>没有安装，则npx会自动的、临时的安装mocha，安装好后，自动运行mocha命令</p></blockquote><h3 id="pnpm原理" tabindex="-1"><a class="header-anchor" href="#pnpm原理" aria-hidden="true">#</a> pnpm原理</h3><ul><li>同 yarn 和 npm 一样，pnpm 仍然使用缓存来保存已经安装过的包，以及使用 pnpm-lock.yaml 来记录详细的依赖版本</li><li>不同于 yarn 和 npm， pnpm 使用<strong>符号链接和硬链接</strong>（可将它们想象成快捷方式）的做法来放置依赖，从而规避了从缓存中拷贝文件的时间，使得安装和卸载的速度更快</li><li>由于使用了<strong>符号链接和硬链接</strong>，pnpm可以规避windows操作系统路径过长的问题，因此，它选择使用树形的依赖结果，有着几乎完美的依赖管理。也因为如此，项目中只能使用直接依赖，而不能使用间接依赖</li></ul><h3 id="注意事项" tabindex="-1"><a class="header-anchor" href="#注意事项" aria-hidden="true">#</a> 注意事项</h3><ul><li>由于 pnpm 会改动 node_modules 目录结构，使得每个包只能使用直接依赖，而不能使用间接依赖，因此，如果使用 pnpm 安装的包中包含间接依赖，则会出现问题(<strong>现在不会了，除非使用了绝对路径</strong>)</li><li>由于 pnpm 超高的安装卸载效率，越来越多的包开始修正之前的间接依赖代码</li></ul><h3 id="概念" tabindex="-1"><a class="header-anchor" href="#概念" aria-hidden="true">#</a> 概念</h3><blockquote><p>要彻底理解pnpm是怎么做的，需要有一些操作系统知识</p></blockquote><ul><li><strong>文件的本质</strong><ul><li>在操作系统中，文件实际上是一个指针，只不过它指向的不是内存地址，而是一个外部存储地址（这里的外部存储可以是硬盘、U盘、甚至是网络）<img src="/vuepress_blog/assets/5-25c97a06.png" alt="image.png"></li><li>当我们删除文件时，删除的实际上是指针，因此，无论删除多么大的文件，速度都非常快。<img src="/vuepress_blog/assets/6-61a48c76.png" alt="image.png"></li></ul></li><li><strong>文件的拷贝</strong><ul><li>如果你复制一个文件，是将该文件指针指向的内容进行复制，然后产生一个新文件指向新的内容</li></ul></li></ul><p><img src="/vuepress_blog/assets/7-a1cfbadd.png" alt="image.png"></p><ul><li><strong>硬链接 hard link</strong><ul><li>硬链接的概念来自于 Unix 操作系统，它是指将一个文件A指针复制到另一个文件B指针中，文件B就是文件A的硬链接</li></ul></li></ul><p><img src="/vuepress_blog/assets/8-21160396.png" alt="image.png"></p><ul><li>通过硬链接，不会产生额外的磁盘占用，并且，两个文件都能找到相同的磁盘内容</li><li>硬链接的数量没有限制，可以为同一个文件产生多个硬链接</li><li>windows Vista操作系统开始，支持了创建硬链接的操作，在cmd中使用下面的命令可以创建硬链接</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>mklink /h 链接名称 目标文件
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>由于文件夹（目录）不存在文件内容，所以文件夹（目录）不能创建硬链接</li></ul><blockquote><p>由于种种原因，在windows操作系统中，通常不要跨越盘符创建硬链接</p></blockquote><ul><li><strong>符号链接 symbol link</strong><ul><li>符号链接又称为软连接，如果为某个文件或文件夹A创建符号连接B，则B指向A。</li></ul></li></ul><p><img src="/vuepress_blog/assets/9-8f138214.png" alt="image.png"></p><ul><li>windows Vista操作系统开始，支持了创建符号链接的操作，在cmd中使用下面的命令可以创建符号链接：</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>mklink /d 链接名称 目标文件
<span class="token comment"># /d表示创建的是目录的符号链接，不写则是文件的符号链接</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>早期的windows系统不支持符号链接，但它提供了一个工具junction来达到类似的功能</p></blockquote><ul><li><strong>符号链接和硬链接的区别</strong><ul><li>硬链接仅能链接文件，而符号链接可以链接目录</li><li>硬链接在链接完成后仅和文件内容关联，和之前链接的文件没有任何关系。而符号链接始终和之前链接的文件关联，和文件内容不直接相关</li></ul></li><li><strong>快捷方式</strong><ul><li>快捷方式类似于符号链接，是windows系统早期就支持的链接方式</li><li>它不仅仅是一个指向其他文件或目录的指针，其中还包含了各种信息：如权限、兼容性启动方式等其他各种属性</li><li>由于快捷方式是windows系统独有的，在跨平台的应用中一般不会使用</li></ul></li><li><strong>node环境对硬链接和符号链接的处理</strong><ul><li><strong>硬链接</strong>：硬链接是一个实实在在的文件，node不对其做任何特殊处理，也无法区别对待，实际上，node根本无从知晓该文件是不是一个硬链接</li><li><strong>符号链接</strong>：由于符号链接指向的是另一个文件或目录，当node执行符号链接下的JS文件时，会使用原始路径</li></ul></li></ul><h3 id="pnpm原理-1" tabindex="-1"><a class="header-anchor" href="#pnpm原理-1" aria-hidden="true">#</a> pnpm原理</h3><ul><li>pnpm使用符号链接和硬链接来构建node_modules目录</li><li>下面用一个例子来说明它的构建方式 <ul><li>假设两个包a和b，a依赖b：</li></ul></li></ul><p><img src="/vuepress_blog/assets/10-af6f2c83.png" alt="image.png"></p><ul><li>假设我们的工程为proj，直接依赖a，则安装时，pnpm会做下面的处理 <ul><li>查询依赖关系，得到最终要安装的包：a和b</li><li>查看a和b是否已经有缓存，如果没有，下载到缓存中，如果有，则进入下一步</li><li>创建 node_modules 目录，并对目录进行结构初始化</li></ul></li></ul><p><img src="/vuepress_blog/assets/11-fa69a322.png" alt="image.png"></p><ul><li>从缓存的对应包中使用硬链接放置文件到相应包代码目录中</li></ul><p><img src="/vuepress_blog/assets/12-66d646a8.png" alt="image.png"></p><ul><li>使用符号链接，将每个包的<strong>直接依赖</strong>放置到自己的目录中</li></ul><p><img src="/vuepress_blog/assets/13-6bfa33d7.png" alt="image.png"></p><pre><code>  - 这样做的目的，是为了保证a的代码在执行过程中，可以读取到它们的直接依赖
</code></pre><ul><li>新版本的pnpm为了解决一些书写不规范的包（读取间接依赖）的问题，又将所有的工程非直接依赖，使用符号链接加入到了 .pnpm/node_modules 中</li><li>在本例中好像没有必要，但是如果b依赖c，a又要直接用c，这种不规范的用法现在pnpm通过这种方式支持了。 <ul><li>但对于那些使用绝对路径的奇葩写法，可能永远也无法支持</li></ul></li><li>在工程的node_modules目录中使用符号链接，放置直接依赖</li></ul><p><img src="/vuepress_blog/assets/14-e9eb576d.png" alt="image.png"></p></div><!--[--><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: chenleilong@51yund.com">chenleilong</span><!--[-->, <!--]--><!--]--><!--[--><span class="contributor" title="email: CDaLoong@gmail.com">DaLoong</span><!--[-->, <!--]--><!--]--><!--[--><span class="contributor" title="email: chenleilong@51yund.com">陈雷龙</span><!----><!--]--><!--]--></span></div></footer><nav class="page-nav"><p class="inner"><span class="prev"><a href="/vuepress_blog/note/%E6%A8%A1%E5%9D%97%E5%8C%96%E5%AD%A6%E4%B9%A0.html" class="" aria-label="模块化"><!--[--><!--]--> 模块化 <!--[--><!--]--></a></span><span class="next"><a href="/vuepress_blog/note/webpack%E5%AD%A6%E4%B9%A0.html" class="" aria-label="Webpack"><!--[--><!--]--> Webpack <!--[--><!--]--></a></span></p></nav><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/vuepress_blog/assets/app-168a97af.js" defer></script>
  </body>
</html>
